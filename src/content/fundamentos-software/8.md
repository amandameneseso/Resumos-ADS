## O que √© ponto flutuante?

**Ponto flutuante** ou¬†**v√≠rgula flutuante** √© um formato de representa√ß√£o¬†de¬†n√∫meros racionais usada nos¬†computadores.

Ao falar em n√∫meros reais a visualiza√ß√£o vinda √† cabe√ßa √©:

**124,79**

- 124: parte inteira
- 79: parte decimal

No entanto, essa representa√ß√£o custa caro, em termos de processamento e armazenamento ao computador havendo a necessidade de utilizar uma outra maneira que favore√ßa tais tarefas. Para trabalhar com a parte fracion√°ria de forma satisfat√≥ria, usa-se a representa√ß√£o por ponto flutuante.

Essa representa√ß√£o baseia-se no deslocamento da v√≠rgula de forma que se obtenha um n√∫mero que a parte inteira seja 1. Isso garante que o n√∫mero esteja no intervalo entre 1 e 2 (ou `1.xxxx` em bin√°rio). Esse deslocamento √© feito por meio de¬†nota√ß√£o cient√≠fica. Esclarecendo: o n√∫mero 124,89 em nota√ß√£o corresponde a 1,2489 x 10¬≤.

O exemplo acima tinha como base a decimal, no entanto o computador trabalha com a base 2 (bin√°rios ‚Äì 0 e 1). Ent√£o um n√∫mero bin√°rio 11,011 em nota√ß√£o corresponde ao 0,11011 x 2¬≤. Esse processo de transcrever um n√∫mero em nota√ß√£o cient√≠fica recebe o nome de normaliza√ß√£o, portanto 0,11011 x 2¬≤¬†est√° normalizado.

Agora, imagine que voc√™ precisa escrever um n√∫mero em um papel, mas voc√™ tem um espa√ßo muito limitado para isso, digamos, apenas 10 quadradinhos.

- Se voc√™ quiser escrever **123.456.789**, cabe nos 9 quadradinhos.
- Se voc√™ quiser escrever **0,000000001**, tamb√©m cabe.
- Mas e se voc√™ precisar de **1.234.567.890.123,45** e tamb√©m de **0,00000000000000000123**?

No seu papel limitado, voc√™ n√£o consegue escrever os dois tipos de n√∫meros com todos os seus detalhes, porque a "v√≠rgula" est√° sempre em uma posi√ß√£o fixa.

O ponto flutuante resolve esse problema, permitindo uma **ampla faixa din√¢mica** (representar n√∫meros muito grandes e muito pequenos) com uma **precis√£o razo√°vel** dentro de um n√∫mero fixo de bits.

A representa√ß√£o em ponto flutuante √© conceitualmente semelhante √† nota√ß√£o cient√≠fica. Em nota√ß√£o cient√≠fica:

- **1.234.567.890** = **1,23 x 10‚Åπ**
- **0,000000123** = **1,23 x 10 ‚Åª ‚Å∑**

**No computador:**

O computador usa um "papel" de tamanho fixo (geralmente 32 quadradinhos, que s√£o bits - 0s e 1s) para guardar um n√∫mero de ponto flutuante. Esse espa√ßo fixo √© dividido em tr√™s campos:

1. **Sinal (1 bit):** Indica se o n√∫mero √© positivo (`0`) ou negativo (`1`).
2. **Expoente (8 bits):** Indica a pot√™ncia pela qual a mantissa deve ser multiplicada. √â a parte que diz "onde est√° o ponto decimal".
3. **Mantissa (23 bits):** D√≠gitos significativos do n√∫mero (o "1,23" do nosso exemplo).

**Exemplo:** O n√∫mero `5.75` no IEEE 754 (32 bits) seria:

```
0   10000001   01110000000000000000000
(Sinal) (Expoente) (Mantissa)
```

>üí° **Como chegar ao formato de 32 bits para o n√∫mero 5.75?**
>    
> Vamos converter o n√∫mero decimal **5.75** para sua representa√ß√£o em ponto flutuante de precis√£o simples (32 bits) no padr√£o IEEE 754.
>    
> Lembre-se que o formato de 32 bits √© dividido em:
>    
> - **Sinal (S):** 1 bit
> - **Expoente (E):** 8 bits
> - **Mantissa (M):** 23 bits (com um "1" impl√≠cito antes do ponto bin√°rio)
>    
> De forma geral, representa-se um n√∫mero em v√≠rgula flutuante da seguinte forma:
>    
> ***N = S √ó M √ó B***
>    
> Onde:
>    
> - S √© o sinal
> - M √© a mantissa (geralmente normalizada para ter um "1" impl√≠cito antes do ponto, no sistema bin√°rio)
> - B √© a base (que √© 2 para computadores)
> - E √© o expoente
>    
> **Passo 1: Converter a parte inteira para bin√°rio**
>    
> Pegamos a parte inteira do n√∫mero, que √© **5**.
>    
> - 5 √∑ 2 = 2 (resto 1)
> - 2 √∑ 2 = 1 (resto 0)
> - 1 √∑ 2 = 0 (resto 1)
>    
> Lendo os restos de baixo para cima: **101**
>    
> **Passo 2: Converter a parte fracion√°ria para bin√°rio**
>    
> Pegamos a parte fracion√°ria do n√∫mero, que √© **0.75**. Multiplicamos por 2 e pegamos a parte inteira do resultado, repetindo com a nova parte fracion√°ria:
>    
> - 0.75 √ó 2 = 1.50 (parte inteira = 1)
> - 0.50 √ó 2 = 1.00 (parte inteira = 1)
>    
> Quando a parte fracion√°ria se torna 0, paramos. Lendo as partes inteiras de cima para baixo: **11**
>    
> **Passo 3: Juntar as partes e normalizar**
>    
> Agora juntamos as partes inteira e fracion√°ria:
>
> 5.75 = 101.11
>    
> Agora, precisamos **normalizar** este n√∫mero. Normalizar significa deslocar o ponto bin√°rio para que haja **apenas um '1' √† esquerda do ponto**. No sistema bin√°rio, isso √© sempre um '1'.
>    
> - `101.11`
> - Para mover o ponto at√© que ele esteja depois do primeiro '1', deslocamos 2 posi√ß√µes para a esquerda: `1.0111`
> - Como deslocamos o ponto 2 posi√ß√µes para a esquerda, o expoente de base 2 √© **+2**.
>    
> Ent√£o, 5.75 = 1.0111√ó2¬≤
>    
> **Passo 4: Determinar o bit de sinal (S)**
>    
> - O n√∫mero 5.75 √© positivo.
> - Portanto, o bit de sinal √© **0**.
>    
> **Passo 5: Calcular o campo do expoente (E)**
>    
> O expoente real (`E`) que encontramos na normaliza√ß√£o √© **+2**. No IEEE 754 de precis√£o simples, o **bias √© 127**.
>    
> Nota: O **127** √© o **valor de excesso (bias)** que √© adicionado ao expoente real de um n√∫mero de ponto flutuante de precis√£o simples (32 bits) antes de ser armazenado. Isso permite que um campo de bits sem sinal represente efetivamente tanto expoentes positivos quanto negativos, simplificando o design e a opera√ß√£o dos circuitos de ponto flutuante na CPU.
>    
> Para obter o valor que vai no campo do expoente (`e`), somamos o expoente real ao bias:
>    
> - `e = E + bias`
> - `e = 2 + 127`
> - `e = 129`
>    
> Agora, precisamos converter **129** para bin√°rio (em 8 bits):
>    
> - 129√∑2=64 (resto 1)
> - 64√∑2=32 (resto 0)
> - 32√∑2=16 (resto 0)
> - 16√∑2=8 (resto 0)
> - 8√∑2=4 (resto 0)
> - 4√∑2=2 (resto 0)
> - 2√∑2=1 (resto 0)
> - 1√∑2=0 (resto 1)
>    
> Lendo os restos de baixo para cima e garantindo 8 bits: 129 = 10000001
>    
> Portanto, o campo do expoente (`e`) √© **10000001**.
>    
> **Passo 6: Determinar a mantissa (m)**
>    
> A mantissa normalizada que obtivemos no Passo 3 √© `1.0111`. No IEEE 754, o "1" antes do ponto √© **impl√≠cito** (n√£o √© armazenado). Pegamos apenas a parte fracion√°ria: `0111`.
>    
> A mantissa precisa ter 23 bits. Preenchemos o restante com zeros √† direita:
>    
> - `0111` + 19 zeros = `01110000000000000000000`
>    
> Portanto, o campo da mantissa (`m`) √© **01110000000000000000000**.
>    
> **Passo 7: Juntar tudo**
>    
> Agora, combinamos o bit de sinal, o campo do expoente e o campo da mantissa na ordem correta (Sinal | Expoente | Mantissa):
>    
> - **Sinal:** `0`
> - **Expoente:** `10000001`
> - **Mantissa:** `01110000000000000000000`
>    
> Juntando, temos:
>    
> `0 10000001 01110000000000000000000`
    
Desta forma √© poss√≠vel cobrir um largo espectro de n√∫meros, maximizando o n√∫mero de bits significativos e consequentemente a precis√£o da aproxima√ß√£o. Esta forma de representa√ß√£o foi criada por¬†Konrad Zuse¬†para os seus computadores¬†Z1¬†(1937) e¬†Z3¬†(1941), batizada, ent√£o, de¬†*Gleitkommazahl*¬†(literalmente¬†*n√∫mero com v√≠rgula escorregante*).

> üí° **Padr√£o IEEE 754**
>
> O **IEEE 754** √© o padr√£o internacional para representar n√∫meros de **ponto flutuante** em computadores. Ele define como esses n√∫meros s√£o armazenados e manipulados para garantir precis√£o e consist√™ncia nos c√°lculos.
>
> Os computadores lidam com n√∫meros bin√°rios (0 e 1), ent√£o armazenar n√∫meros decimais como `3.14` ou `0.1 + 0.2` pode ser um desafio. O **IEEE 754** resolve isso padronizando a forma como os n√∫meros s√£o representados, permitindo c√°lculos mais previs√≠veis.
>
> Os dois formatos mais utilizados s√£o:
>
> 1. **Precis√£o simples (32 bits):**
>    - 1 bit para o sinal.
>    - 8 bits para o expoente.
>    - 23 bits para a mantissa (com um "1" impl√≠cito, o que d√° 24 bits de precis√£o).
>    - **Faixa:** Pode representar n√∫meros de aproximadamente ¬±1.18√ó10^(-38) a ¬±3.4√ó10^(38).
>    - **Precis√£o:** Cerca de 7 a 8 casas decimais significativas.
> 2. **Precis√£o dupla (64 bits):**
>    - 1 bit para o sinal.
>    - 11 bits para o expoente.
>    - 52 bits para a mantissa (com um "1" impl√≠cito, o que d√° 53 bits de precis√£o).
>    - **Faixa:** Pode representar n√∫meros de aproximadamente ¬±2.22√ó10^(-308) a ¬±1.80√ó10^(308).
>    - **Precis√£o:** Cerca de 15 a 17 casas decimais significativas.

### Problema da Precis√£o (0.1 + 0.2)

No JavaScript (e outras linguagens que usam IEEE 754), certos n√∫meros decimais n√£o podem ser representados **exatamente**, resultando em pequenos erros de precis√£o.

```jsx
console.log(0.1 + 0.2); // 0.30000000000000004
```

Isso acontece porque `0.1` e `0.2` n√£o t√™m uma representa√ß√£o bin√°ria exata, causando um pequeno erro no c√°lculo. Ao converter fra√ß√µes decimais como 0.1 para o sistema bin√°rio (base 2), muitas delas resultam em uma representa√ß√£o **infinita e peri√≥dica** (como uma d√≠zima peri√≥dica em decimal).

Como o computador tem um n√∫mero **limitado** de bits para armazenar essa fra√ß√£o, ele precisa **arredondar** a representa√ß√£o. Assim, 0.1 √© armazenado como um n√∫mero bin√°rio *muito pr√≥ximo*, mas n√£o *exatamente* 0.1.

Quando voc√™ soma essas aproxima√ß√µes (ex: 0.1 + 0.2), os pequenos erros se acumulam, resultando em um valor que √© ligeiramente diferente do esperado (como 0.30000000000000004 em vez de 0.3).

**Solu√ß√£o:** Usar `toFixed()` ou `toPrecision()` para arredondar:

```jsx
console.log((0.1 + 0.2).toFixed(2)); // "0.30"
```

Isso √© crucial em c√°lculos financeiros, cient√≠ficos ou de engenharia onde a precis√£o absoluta √© vital. Por isso, para dinheiro, geralmente se usam tipos de dados inteiros que representam centavos, ou bibliotecas de "decimal fixo".