# Desenvolvimento colaborativo

## 1. Como nasce um software?

- O processo de criação de software, também conhecido como Ciclo de Vida do Desenvolvimento de Software (SDLC), é uma abordagem estruturada para projetar, desenvolver, testar e implantar um sistema. Ele garante que o software final atenda aos requisitos do cliente, seja de alta qualidade e seja entregue dentro do prazo e orçamento. 
- O processo é composto por várias etapas, que podem variar dependendo da metodologia utilizada, mas geralmente seguem a seguinte sequência: 
    
    1. Planejamento/Análise de requisitos
    2. Design ou projeto
    3. Implementação ou codificação
    4. Testes e verificação
    5. Implantação (Deploy)
    6. Manutenção

![image.png](https://universoprojeto.wordpress.com/wp-content/uploads/2013/10/sdlc-waterfall-cvds-cascata.png)

- O processo de criação de um software começa muito antes da codificação, com o **levantamento de requisitos** para coletar as funções necessárias. A rotina de desenvolvimento envolve baixar o código de um repositório, codificar, validar e integrar os novos códigos, e testar as funcionalidades. É crucial **baixar novas versões do código** do repositório múltiplas vezes ao longo do projeto, e sistemas de controle de versão são utilizados para isso, com a boa prática de dar nomes adequados aos repositórios.
- Na fase de **codificação**, **más práticas como código duplicado** e manipulações desnecessárias no Banco de Dados podem afetar o desempenho. É essencial observar critérios básicos como formatação e nomenclatura.
- A **validação do código** é feita pelo próprio programador para verificar se tudo funciona conforme especificado, sendo necessária para a integração sem erros. Boas práticas incluem programação em pares e consulta a casos de uso.
- Os **testes de software** não devem ser feitos apenas no final; boas práticas incluem a automatização, o desenvolvimento orientado a testes e a realização de testes durante a codificação.

### 1.1 Trabalho em equipe

O **trabalho em equipe** e a colaboração são fundamentais para o sucesso de uma aplicação, pois "são as pessoas que fazem um software". A Metodologia Ágil, como o Scrum, valoriza as pessoas. As **reuniões diárias (dailys)** no Scrum duram no máximo 15 minutos e servem para atualizar a equipe sobre o trabalho do dia, priorizar tarefas e focar no cliente. Embora reuniões sejam uma boa estratégia para alinhar o time, o **excesso de reuniões pode atrapalhar a produtividade**. Para que as reuniões sejam produtivas, é importante seguir boas práticas. Uma pesquisa do Ministério Público do Rio de Janeiro (MPRJ) apontou as seguintes mudanças importantes:

- **Escolha criteriosa de temas**.
- **Envio prévio da pauta**.
- **Definição de quem faz o quê**, assegurando que todos saiam cientes de seus compromissos.
- **Limitação do tempo total**.
- **Limitação de participantes**, convidando apenas quem realmente agrega valor para evitar perda de tempo.

### 1.2 Boas práticas em reuniões

Para **reuniões eficientes**, especialmente por webconferência, a Zendesk sugere:

- **Condução:** não se atrasar, o convidante deve guiar, prepare-se, apresente os participantes, estabeleça regras, seja direto e objetivo, e pergunte como as pessoas estão se sentindo.
- **Eficiência:** verifique se o assunto pede realmente uma reunião, marque reuniões mais curtas, evite horários fora do comercial, envie convites com contexto, convide apenas pessoas necessárias, esteja presente e evite distrações, tenha cuidado com câmera e microfone, e faça uma ata.

A popularização das webconferências, devido ao isolamento social imposto pela pandemia da covid-19, trouxe vantagens como **economia de custo e tempo** devido à logística. No entanto, surgiu o termo **"Zoom Fadigue"** (ou fadiga do Zoom), que se refere à exaustão física e mental, cansaço, preocupação, ansiedade, esgotamento e estresse causados pelo uso prolongado de qualquer ferramenta de webconferência. As causas, segundo estudos de Stanford, incluem:

- **Excesso de contato visual**, onde todos se olham simultaneamente, e rostos grandes na tela causam estresse.
- **Muito tempo vendo a si mesmo**, o que pode causar estresse e desconforto.
- **Redução da mobilidade**, afetando o desempenho cognitivo.
- **Maior carga cognitiva**, pois a comunicação não verbal exige mais esforço em chats de vídeo do que cara a cara. Algumas atitudes para minimizar a fadiga incluem desabilitar a própria imagem na videoconferência e desligar a câmera por alguns minutos para se movimentar.

## 2. Ferramentas colaborativas de trabalho em equipe

**Ferramentas de colaboração** são softwares ou plataformas que permitem o compartilhamento de arquivos e a comunicação eficaz entre os membros de um projeto. Exemplos incluem:

- **Trello:** Uma **ferramenta visual** para gerenciamento de qualquer tipo de projeto, fluxo de trabalho ou monitoramento de tarefas. Trabalha com conceitos de quadros, listas e cartões, permitindo adicionar membros, datas de entrega e comentários. Possui uma versão gratuita com recursos limitados.
- **Jira:** Uma ferramenta de **gestão de projetos** mais indicada para **empresas grandes**, com painéis **Scrum** personalizados para desenvolvimento ágil. Originalmente um rastreador de bugs, agora gerencia diversos casos de uso, como gestão de casos de teste e requisitos.
- **Slack:** Uma ferramenta de **mensagens corporativas** que organiza o trabalho em "canais" para diferentes assuntos.
- **Teams (Microsoft):** Gratuito para competir com o Slack, visa substituir o e-mail, oferecendo chamadas de vídeo, edição de documentos e integração com outros aplicativos.
- **Discord:** Sua evolução permitiu que atualmente seja usado no mundo corporativo. Pode ser usado online sem instalação. Além do mundo corporativo, muitas universidades também estão utilizando o Discord para que os alunos possam socializar, organizar-se e se enturmar.
- **Zoom:** Plataforma de reunião virtual popular, oferece videoconferência e troca de mensagens.

## 3. Versionamento e reúso

O **reúso no desenvolvimento de software** vai além da simples reutilização de códigos; refere-se a qualquer parte de um sistema implementada anteriormente, como especificações, módulos, arquiteturas e padrões. Pode ser aplicado em qualquer fase do projeto, da concepção à implantação.

As **vantagens do reúso** incluem o aumento da produtividade, redução do tempo de entrega do produto e aumento da qualidade do software. A ideia de reúso surgiu na década de 1960 na indústria de CIs e foi introduzida no desenvolvimento de software devido ao aumento da complexidade dos sistemas. O reúso afeta diversos **fatores de qualidade de software**, conforme Rozante (2003):

- **Funcionalidade:** Melhorada pela reutilização de sistemas similares como protótipos e pela descoberta precoce de requisitos.
- **Confiabilidade:** Aumenta com o uso de componentes bem testados, mas pode ser comprometida pelo uso incorreto.
- **Usabilidade:** Pode ser aprimorada por componentes com maior dedicação no desenvolvimento, mas pequenas diferenças podem torná-los inaceitáveis.
- **Eficiência:** Melhorada com maior esforço na construção de componentes eficientes e adaptação para necessidades específicas.
- **Manutenibilidade:** Modificações podem ser incorporadas ou planejadas nos requisitos, e custos podem ser divididos entre reutilizadores.
- **Portabilidade:** Naturalmente incorporada aos componentes reutilizáveis.

Apesar dos benefícios, o reúso enfrenta desafios para sua implantação. As **dificuldades** incluem:

- **Síndrome NIH (Not Invented Here):** Profissionais preferem reescrever a reutilizar código de terceiros.
- **Medo de falhas:** Preocupação com a introdução de falhas por componentes reutilizados.
- **Custo da reutilização:** Envolve o custo de tornar algo reutilizável, de reutilizá-lo e de definir o processo de reúso.
- **Questões legais:** Podem surgir violações de direitos autorais se componentes desenvolvidos sob contrato são reutilizados para outros clientes.
- **Compreender a parte reutilizada:** Dificuldade em saber o que e como reutilizar.
- **Implementação de práticas e mudança de mentalidade:** Os benefícios do reúso são percebidos a longo prazo, o que pode desmotivar a equipe.

O **versionamento** contribui para o reúso. De forma simples, o versionamento armazena arquivos de um projeto em um repositório, registrando o histórico de versões. Programadores podem acessar a última versão, fazer cópias locais, realizar alterações e submeter ao repositório, além de recuperar atualizações de outros membros.

Antes dos sistemas de controle de versão, o controle era manual e propenso a perdas ou sobreposições. Com o advento do controle de versão, a tarefa foi simplificada, facilitando o reúso e adaptação de códigos.

## 4. Repositórios de códigos

**Repositórios de códigos** são locais onde todos os artefatos (componentes, códigos) são armazenados. Existem duas perspectivas:

1. **Repositório de gerência de configuração:** Referem-se aos sistemas de controle de versão (VCS ou SCM).
    - **Tipos de SCM:**
        - **Centralizado:** Possui um único servidor central e várias estações de trabalho. Exemplo: **Subversion (SVN)**, que é de código aberto e indicado para equipes menores em um mesmo espaço físico.
        - **Descentralizado (distribuído):** Possui diversos repositórios autônomos e independentes para cada desenvolvedor. Exemplos:
            - **Git:** Desenvolvido por Linus Torvalds, distribuído (cada diretório de trabalho é um repositório completo), não depende de servidor central, possui interface gráfica agradável, é eficaz e de alto desempenho.
            - **BitKeeper:** Deu origem ao Git. Distribuído, rápido e escalável.
            - **Mercurial:** Ferramenta gratuita e distribuída, utilizada por grandes empresas como Facebook e Google. Escrito em Python/C, possui interface fácil e intuitiva, é open source.
2. **Repositório de reutilização:**
    - **Bootstrap:** Biblioteca de componentes front-end popular, gratuita para desenvolvimento HTML, CSS e JS, com abordagem "mobile first".
    - **GitHub:** Plataforma de hospedagem de código que incorpora recursos de controle de versão via Git. Possui repositórios abertos que permitem o acesso e reúso de códigos.
    - **Spring:** Framework open source para a plataforma Java, focado na infraestrutura de aplicativos empresariais, permitindo que as equipes se concentrem na lógica de negócios.
    - **Angular:** Framework para desenvolvimento web front-end, criado pelo Google utilizando TypeScript, usado para aplicações mobile e web desktop.

Além dos repositórios de código tradicionais, existem os **repositórios de ideias**, que servem como espaço para desenvolvedores trocarem informações e dicas. Exemplos:

- **Oracle Developer:** Oferece dicas, eventos e ferramentas para desenvolvedores, disponibilizando códigos no GitHub e apoiando tecnologias de código aberto.
- **Cisco (Cisco Networking Academy/Netacad):** Um programa global de educação em TI e segurança cibernética que capacita pessoas para oportunidades de carreira, formando parcerias com instituições de ensino em 180 países.
- **AWS (Amazon Web Services):** Iniciou em 2002 para infraestrutura de TI, utilizando o conceito de "dogfooding" (desenvolver e usar os próprios serviços). A AWS Academy oferece um currículo gratuito de computação na nuvem para ensino superior.
- **Mozilla (MDN - Mozilla Developers Network):** Plataforma de aprendizagem para tecnologias web, como CSS, HTML, JavaScript e desenvolvimento de add-ons para Firefox, focada em documentar a "open web".
- **Manuais de Linguagens:** Fontes importantes de conhecimento.
    - **Manual do Python:** Disponível online, descreve a sintaxe e semântica central da linguagem e sua biblioteca padrão. Python é uma linguagem poderosa, fácil de aprender e com estruturas de dados eficientes.
    - **Site do Java (Oracle):** Contém seção para desenvolvedores com artigos, podcasts e tutoriais para aprender a linguagem Java.
    - **W3Schools:** Site com referências e exemplos didáticos de comandos em várias linguagens (C, Java, Python), útil para iniciantes.

## 5. Testes de software, controle de qualidade e deploy

Os **testes de software** garantem que o software funcione corretamente e atenda às especificações. Eles são parte da **Verificação e Validação (V&V)**:

- **Verificação:** Garante que o software implementa corretamente uma função específica.
- **Validação:** Assegura que o software foi criado e pode ser rastreado de acordo com os requisitos do cliente.

O objetivo dos testes é **revelar erros**. No contexto de testes de software, os termos têm conotações específicas, embora sejam usados de forma flexível no dia a dia:

- **Error/mistake (erro/engano):** Ação humana que produz um resultado incorreto.
- **Fault (defeito/bug):** Manifestação de um erro no software.
- **Failure (falha):** Incapacidade de um sistema ou componente de software de executar suas funções exigidas. Uma falha ocorre quando uma *fault* é encontrada.

Os **custos de modificar um software aumentam conforme o projeto avança**; quanto mais cedo os *bugs* forem detectados nos testes, mais fácil e barato será corrigi-los.

A **Garantia de Qualidade de Software (SQA)** é um conjunto de atividades técnicas aplicadas durante todo o processo de desenvolvimento para assegurar a qualidade do produto. A **estratégia de teste de software** segue um conceito em espiral (Pressman):

- **Teste de Unidade (Unit Testing):** Começa no centro da espiral, foca em pequenas unidades (componentes, classes) do software. Geralmente é responsabilidade do desenvolvedor.
- **Teste de Integração:** Verifica a comunicação e integração correta entre as unidades, realizado após o teste individual das unidades.
- **Teste de Validação:** Valida os requisitos estabelecidos em relação ao software criado.
- **Teste de Sistema:** Teste o software e outros elementos como um todo, verificando se todos os requisitos foram atendidos e se atinge um padrão de qualidade para o usuário final.

![image.png](https://arquivos.qconcursos.com/images/provas/66118/1ff0a50fa6c2fac9307f.png)

Após todas as fases, é feita a **implantação do software, conhecida como deploy**. Esta tarefa é complexa, exigindo a inclusão das dependências do software (interpretadores, compiladores, pacotes, extensões), além da configuração do ambiente, licenças e senhas de banco de dados. Para minimizar o tempo e esforço no provisionamento de servidores e gerenciamento, utiliza-se o conceito de **contêiner**. Um contêiner resolve o problema comum de um programa funcionar em um ambiente de desenvolvimento e não em outro.

- Um [**contêiner**](/disciplina/fundamentos-software/aula/9) é um pacote que contém um software e todas as dependências necessárias para sua execução, facilitando o deploy.

Em suma, o desenvolvimento colaborativo é um processo multifacetado que se beneficia enormemente da gestão de equipes, ferramentas de colaboração, práticas de versionamento e reúso, e estratégias rigorosas de teste, culminando em um deploy eficiente através de tecnologias como contêineres.

![image.png](/images/divider2.png)

## Perguntas

1. Qual é a importância do levantamento de requisitos no início do ciclo de vida de um software?
2. No contexto do Scrum, qual o propósito das "dailys" e por que elas são limitadas a 15 minutos?
3. Quais são as principais causas da "Fadiga do Zoom", conforme os estudos da Stanford?
4. Qual a diferença entre Git e GitHub?
5. O que significa dizer que o Git é um sistema de controle de versão "distribuído"?
6. No teste de software, qual a diferença fundamental entre "verificação" e "validação"?
7. Por que a detecção precoce de bugs no processo de desenvolvimento de software é tão importante?
8. Como um contêiner, como o Docker, resolve o problema do "funciona na minha máquina, mas não em outro ambiente"?