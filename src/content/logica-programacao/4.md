# Estruturas de Repetição

## 1. Estruturas de Repetição

Um dos desafios comuns na programação é a repetição de tarefas. Imagine que você precisa imprimir os números de 1 a 5. Uma maneira de fazer isso seria escrevendo uma linha de código para cada número:

```python
print(1)
print(2)
print(3)
print(4)
print(5)
```

Embora essa abordagem funcione para poucos números, ela se torna inviável se a tarefa for, por exemplo, imprimir os números de 1 a 1.000. O código ficaria extremamente longo, trabalhoso e difícil de gerenciar.

Para resolver esse problema, as linguagens de programação oferecem **estruturas de repetição**, também conhecidas como **loops** ou **laços**. Essas estruturas permitem que um bloco de código seja executado repetidamente até que uma condição específica seja alcançada.

Com uma estrutura de repetição, o mesmo problema de imprimir os números de 1 a 5 pode ser resolvido com um código muito mais simples e eficiente, pois você só precisa escrever a instrução uma única vez.

## 2. Estrutura de Repetição - while

A estrutura `while` (enquanto) repete um bloco de instruções **enquanto uma determinada condição se mantém verdadeira**. Se a condição se torna falsa, o programa desvia para a primeira linha de código após o bloco de repetição.

![image.png](/images/image21.png)

- **Sintaxe:** A estrutura `while` é representada pela palavra-chave `while`, seguida da condição lógica (entre parênteses opcionais), e obrigatoriamente de dois pontos (`:`). Todas as instruções que pertencem ao bloco iterativo devem ser **indentadas**. O Python trabalha com a indentação para identificar o que pertence ao seu bloco, portanto não requer um finalizador para ele.
    
    ```python
    while (condição):
      instrução
    ```
    
- **Exemplo:**
    
    ```python
    x = 1
    while (x <= 5):
        print(x)
        x = x + 1
        
    # Saída:
    1
    2
    3
    4
    5
    ```
    
    Nesse código, `x` é inicializado em 1. O laço repete enquanto `x <= 5`. Dentro do laço, `x` é impresso (`print(x)`) e depois **incrementado** (`x = x + 1`). O incremento é crucial, pois sem ele, o laço ficaria em execução infinita (serve para limitar o número de vezes que o laço é executado).
    
    ![image.png](/images/image19.png)
    

### 2.1 Contadores

- A estrutura `while` é versátil para criar contadores. É possível permitir que o usuário defina os valores inicial e final da contagem.
    
    ```python
    inicial = int(input('Qual valor deseja iniciar a contagem?'))
    final =   int(input('Qual valor deseja encerrar a contagem?'))
    x = inicial
    while (x <= final):
        print(x)
        x = x + 1
    ```
    
- Neste caso, a variável `x` é inicializada com o valor fornecido pelo usuário, e a condição do laço verifica se `x` atingiu o valor final também fornecido pelo usuário.
- Pode-se também aninhar uma **estrutura condicional (if) dentro do laço de repetição** para verificar condições adicionais. Por exemplo, para imprimir na tela apenas valores dentro de um intervalo especificado pelo usuário e que sejam pares. É importante que o incremento (`x = x + 1`) aconteça em todas as iterações do laço, e não apenas dentro da condicional aninhada, para evitar loops incorretos.
    
    ```python
    inicial = int(input('Qual valor deseja iniciar a contagem?'))
    final = int(input('Qual valor deseja encerrar a contagem?'))
    a = inicial
    while (a <= final):
      if (a % 2 == 0):
        print(a)
      a = a + 1
    ```
    

### 2.2 Acumuladores

- Muitas vezes necessitamos de variáveis capazes de acumular totais, como por exemplo realizar o somatório de um conjunto de dados. O que difere um contador de um acumulador é que o primeiro acrescenta valores constantes, enquanto que o segundo, valores variáveis distintos.
- Em problemas que envolvem acumuladores, normalmente necessitamos de um contador também, para que sirva de variável de controle do laço de repetição.
- **Exemplo:**
    
    ```python
    soma = 0
    cont = 1
    while (cont <= 5):
      x = float(input(f'Digite a {cont}ª nota:'))
      soma = soma + x
      cont = cont + 1
    media = soma / 5
    print(f'Média final: {media}')
    ```
    
- Análise do código:
    1. **Inicialização**: Inicializamos as variáveis `soma` e `cont` para `0` e `1`, respectivamente. Isso é essencial para que a soma comece do zero e o contador do laço inicie corretamente.
    2. **Laço de repetição (`while`)**: A condição `while (cont <= 5):` garante que o bloco de código seja executado exatamente cinco vezes, que é o número de notas que desejamos coletar.
    3. **Entrada de dados**: Dentro do `while`, a linha `x = float(input(f'Digite a {cont}ª nota:'))` solicita cada nota ao usuário. O `float()` permite que o usuário digite notas com casas decimais (como `8.5`).
    4. **Somatório**: A linha `soma = soma + x` acumula as notas a cada iteração, somando a nota atual (`x`) à soma que já foi calculada.
    5. **Incremento do contador**: `cont = cont + 1` é crucial para que o laço avance e, eventualmente, pare quando `cont` for igual a 5.
    6. **Cálculo final**: Fora do `while`, a linha `media = soma / 5` faz o cálculo final, dividindo a soma total pelo número de notas (5).
    7. **Saída**: O `print(f'Média final: {media}')` exibe o resultado.
- É **fundamental inicializar a variável acumuladora (soma) com zero** para garantir que o programa inicie o somatório corretamente. O exemplo também mostra como calcular a média final dividindo o somatório pela quantidade de dados.

## 3. Tópicos importantes com laços em Python

### 3.1 Operadores especiais de atribuição

A linguagem Python permite simplificar operações comuns de atribuição (`x = x + 1`) usando operadores combinados, como **`+=`**. Essa forma abreviada é uma herança das linguagens C/C++.

- Exemplos:
    
    `x += 1` → `x = x + 1`
    
    `x -= 1` → `x = x - 1`
    
    `x *= 2` → `x = x * 2`
    
    `x /= 2` → `x = x / 2`
    
    `x **= 2` → `x = x ** 2`
    
    `x //= 4` → `x = x // 4`
    
    ```python
    x = 1
    while (x <= 5):
      print(x)
      x += 1 #Equivalente: x = x + 1
    ```
    

### 3.2 Validando dados de entrada com um loop

Uma necessidade comum é a de validar dados digitados pelo usuário. Por exemplo, vamos supor que você precise criar um algoritmo que receba um valor do tipo inteiro e positivos. Qualquer valor negativo, ou zero, deve ser rejeitado pelo programa e um novo valor deve ser solicitado.

Podemos validar o nosso dado de entrada através de um laço de repetição, obrigando o usuário a digitar um valor positivo para que nosso programa avance. Ou seja, enquanto não for digitado um dado válido, o programa ficará preso de maneira indefinida neste laço. Vejamos como ficaria um exemplo no código a seguir:

```python
# Validando a entrada
x = int(input('Digite um valor maior do que zero: '))
while (x <= 0):
  x = int(input('Digite um valor maior do que zero: '))
print(f'Você digitou {x}. Encerrando o programa...')
```

```python
# saída:
Digite um valor maior do que zero: -6
Digite um valor maior do que zero: 0
Digite um valor maior do que zero: -1
Digite um valor maior do que zero: 12
Você digitou 12. Encerrando o programa...
```

O laço permanece ativo enquanto a condição for **contrária** ao que é desejado (`x <= 0`), garantindo que o programa só avance com um dado válido. Outro exemplo é permitir que o usuário digite mensagens até que uma palavra específica, como "sair", seja digitada para encerrar o programa.

### 3.3 Interrompendo um loop com `break`

Vamos revisitar o algoritmo que acabamos de desenvolver na seção 3.2. Mas agora vamos criar uma lógica diferente utilizando uma instrução chamada de `break`. A instrução `break` serve para simplesmente encerrar um laço de repetição abruptamente, independentemente do estado da variável de controle do laço. Podemos utilizar o comando `break` somente invocando o seu nome quando desejarmos:

```python
print('Digite uma mensagem que irei repetir para você!')
print('Para encerrar escreva "sair".')
while True:
  texto = input('')
  print(texto)
  if texto == 'sair':
    break
print('Encerrando o programa...')
```

No exercício que acabamos de resolver, usamos uma condição que chamamos de loop infinito (`while True`). Ela é assim chamada pois a condição por si só nunca terá um final, uma vez que não tem variável de controle para finalizar o laço.

Dessa forma, precisamos de uma maneira alternativa de encerrar o loop através do `break`. Porém, devemos tomar bastante cuidado e usar o loop infinito com muita cautela. Esquecer o `break` faz com que o programa nunca termine, podendo causar travamentos.

### 3.4 Voltando ao início do loop com `continue`

O comando `continue` não encerra o laço, mas serve para **retornar o laço ao início** a qualquer momento, independentemente do estado da variável de controle da condicional do laço. Vejamos como fica um código para realizar um login de acesso em um sistema, onde o usuário deve informar seu nome e sua senha:

```python
while True:
  nome = input('Qual o seu nome?')
  if (nome != 'Amanda'):
    continue # volta para inicio do laço
  senha = input('Qual a sua senha?')
  if (senha == 'ceuazul'):
    break # encerra o laço
print('Acesso concedido.')
```

No programa acima, note que temos novamente o laço de repetição infinito. Vamos supor que o nome do usuário é Amanda. Portanto, na linha 3 temos uma condição que verifica se, caso o nome digitado seja diferente de Amanda, a instrução `continue` entra em execução, fazendo o programa retornar ao início do laço e solicitar um novo nome.

Quando o nome correto é digitado, o programa avança para solicitar a senha. Agora, na parte da senha estamos usando a instrução `break`. Sendo assim, quando a senha correta for digitada, o `break` executa, encerrando o laço imediatamente e realizando o login de acesso.

### 3.5 Valores Truthy e Falsey

Em Python, além de `True` e `False`, outros dados não booleanos podem ser interpretados como verdadeiros (`Truthy`) ou falsos (`Falsey`) em contextos condicionais. O numeral zero (inteiro ou flutuante) e uma string vazia são considerados **Falsey**. Todos os outros dados são **Truthy**.

- **Falsey**: Valores que são considerados **falsos**. Isso inclui o número zero (`0` ou `0.0`) e strings vazias (`""`).
- **Truthy**: Todos os outros valores que não são Falsey são considerados **verdadeiros**.
    
    ```python
    nome = ''
    while not nome:
      # encerra o laço quando nome não estiver vazio
      nome = input('Digite seu nome:')
    valor = int(input('Digite um número qualquer:'))
    if valor: # Equivalente if valor != 0:
      print('Você digitou um valor diferente de zero.')
    else:
      print('Você digitou zero.')
    ```
    

Vejamos o exemplo acima. Nele, inicializamos a variável nome com uma string vazia. Isso significa que, se utilizarmos esta variável em um teste lógico com ela estando vazia, seu valor será interpretado como False. Na linha 2, fazemos um teste lógico onde estamos negando a variável
nome (`while not nome`). Fazer isso é o equivalente a fazer `while True`, pois a string vazia é False e, ao negá-la, invertemos seu valor para True. Assim, fazemos com que o programa caia dentro do laço de repetição e solicite um nome.

Após o laço de repetição, temos a leitura de um valor numérico e inteiro qualquer na variável valor. Em seguida, fazemos um teste condicional colocando somente `if valor`. Quando fazemos isso, o Python irá interpretar o número digitado como um valor lógico. Caso você digite zero, o teste lógico resultará em False, caindo no else. Caso você digite qualquer outro número, como 10 por exemplo, o teste lógico será True.

## 4. Estrutura de Repetição - for

A estrutura `for` é comumente empregada em situações onde o **número de vezes que o laço irá executar é conhecido previamente**. Diferente do `while`, que tem duração indefinida, o `for` tipicamente testa uma condição de comparação lógica para verificar se uma variável de controle atingiu um valor de parada.

**Sintaxe:**

```python
for <var> in range(<inicial>, <final>, <incremento>):
    Instrução
```

- `var` é a variável de controle do laço (normalmente adotamos a letra i)
- `range()` é uma função que define o intervalo da iteração
    - `inicial` é o valor que iremos iniciar a contar
    - `final` é o valor final de parada da contagem
    - `incremento` é o passo que iremos utilizar para incrementar a variável de controle.

**Como funciona?**

O `for` percorre cada elemento da sequência, um de cada vez, e executa o bloco de código dentro do laço para cada um desses elementos.

```python
for numero in [1, 2, 3, 4, 5]:
```

- O `for` pega o primeiro elemento da lista (`1`) e executa o código.
- Em seguida, ele pega o segundo elemento (`2`) e executa o código.
- Esse processo continua até que todos os elementos da lista sejam processados.

**Exemplo com `range()`:**

A função `range()` é muito comum em laços `for`, pois ela gera uma sequência de números.

Vejamos um exemplo prático. Iremos refazer o primeiro exercício desta etapa, onde queremos imprimir na tela 5 valores inteiros e sequenciais. Observe o código a seguir:

```python
for i in range(6):
    print(i)
```

- Cria uma sequência de 0 a 5 (0, 1, 2, 3, 4, 5).
- O laço será executado 6 vezes.

```python
# saída:
1
2
3
4
5
6
```

- Com um argumento: `range(final)` → vai de **0 até o fim (final - 1)**
- Com dois argumentos: `range(início, fim)` → vai de **início até o fim (final - 1)**
- Com três argumentos: `range(início, fim, passo)` → usa um **passo** (positivo ou negativo)

**Exemplos:**

- `for i in range(6):` imprime de 0 a 5.
- `for i in range(1, 6, 1):` imprime de 1 a 5 com passo de 1 em 1.
- `for i in range(10, 0, -2):` imprime 10, 8, 6, 4, 2 (contagem decrescente de 2 em 2).

### 4.1 Comparativo `while` e `for`

Na figura, foram realizadas marcações coloridas que indicam o equivalente em ambos os códigos. Em laranja, está assinalado o valor inicial da iteração. No `while`, precisamos explicitar uma instrução de atribuição `x = 1`. Na estrutura do `for`, esta linha é representada pelo primeiro valor inserido na função `range`.

![image.png](/images/image20.png)

Em azul marcamos a condição de parada. No `while`, explicitamos a condição de parada `x < 6`. No `for`, esta condição está implícita no segundo valor colocado na função `range`. Por fim, o incremento no `while` também é criado de maneira explicita, com `x = x + 1`, já no `for` ele é representado pelo terceiro valor na função `range`.

Em suma, podemos concluir que o laço de repetição do tipo `for` é capaz de resolver os mesmos problemas que o `while`, desde que estes problemas tenham um **número fixo de iterações**. Em situações como esta, é indiferente utilizar qualquer uma das duas estruturas, sem prejuízo algum quanto ao desempenho do algoritmo. Ficando a critério do desenvolvedor empregar a que melhor lhe convém.

## 5. Estruturas de Repetição Aninhadas

Assim como nas estruturas condicionais, é possível **combinar diversas estruturas de repetição**, aninhando um laço dentro de outro, para resolver algoritmos mais complexos. Pode-se misturar `while` e `for` sem problemas.

Vamos ver um exemplo de aninhamento de laços através de um exemplo de cálculo de tabuada. Vamos escrever um algoritmo em Python que calcule a tabuada de todos os números de 1 até 10 e, para cada número, vamos calcular a tabuada multiplicando-o pelo intervalo de 1 até 10. Vejamos primeiro a implementação com dois `while`:

```python
tabuada = 1
while tabuada <= 10:
    print(f'TABUADA DO {tabuada}:')
    i = 1
    while i <= 10:
        print(f'{tabuada} x {i} = {tabuada * i}')
        i += 1
    tabuada += 1
```

Neste exemplo, o laço externo (`while tabuada`) executa 10 vezes. Para cada iteração do laço externo, o laço interno (`while i`) executa 10 vezes. Assim, o laço interno executa um total de 100 vezes (10x10). A inicialização e o incremento das variáveis de controle devem ser feitos corretamente, prestando atenção à indentação.

É interessante frisarmos que é possível refazer o mesmo exercício empregando laços `for`. Como ambos loops são finitos, o `for` se encaixará muito bem nesta implementação também. Veja como ficaria o algoritmo a seguir:

```python
for tabuada in range(1, 11, 1):
  print(f'TABUADA DO {tabuada}:')
  for i in range(1, 11, 1):
    print(f'{tabuada} x {i} = {tabuada * i}')
```

Para finalizarmos, podemos inclusive misturar `while` e `for`. A seguir, o laço externo foi implementado com `while`, e o interno com `for` (o inverso também seria válido).

```python
tabuada = 1
while tabuada <= 10:
  print(f'TABUADA DO {tabuada}:')
  for i in range(1, 11, 1):
    print(f'{tabuada} x {i} = {tabuada * i}')
  tabuada += 1
```

![image.png](/images/divider2.png)

## Exercícios

**Exercício 1:** Crie um programa que calcule a tabuada de um número escolhido pelo usuário. Imprima na tela a tabuada deste número de 1 a 10.

```python
numero = int(input("Digite um número para ver a tabuada: "))
multiplicador = 1

print(f"\nTabuada do {numero}:")

while multiplicador <= 10:
    resultado = numero * multiplicador
    print(f"{multiplicador} x {numero} = {resultado}")
    multiplicador = multiplicador + 1
```

**Exercício 2:** Escreva um algoritmo que calcule a média dos números pares de 1 até 100 (1 e 100 inclusos). Implemente o laço usando `for`.

```python
soma = 0
qtd = 0
for i in range(1,101):
  if (i % 2 == 0):
    soma += i
    qtd += 1
media = soma / qtd
print(f'A média dos pares de 0 até 100 é: {media}')
```

**Exercício 3:** Escreva um algoritmo que calcule e exiba a tabuada de um número escolhido e digitado pelo usuário. A tabuada deve ser calculada até um determinado número n, também fornecido pelo usuário. Implemente o laço usando `for`.

```python
numero = int(input("Digite um número para calcular: "))
limite = int(input("Digite até qual número a tabuada deve ir: "))

print(f"Tabuada do {numero} (de 1 a {limite}):")

# O range(1, limite + 1) garante que o limite seja incluído
for i in range(1, limite + 1):
    resultado = numero * i
    print(f"{numero} x {i} = {resultado}")
```

**Exercício 4:** Escreva um algoritmo que repetidamente pergunte ao usuário qual sua idade e seu sexo (M ou F). Para cada resposta o programa deve responder imprimir a mensagem:
“Boa noite, Senhor. Sua idade é <IDADE>” caso gênero masculino ou
“Boa noite, Senhora. Sua idade é <IDADE>” caso gênero feminino.
O programa deve encerrar quando o usuário digitar uma idade negativa.

```python
while True:
    idade = int(input("Digite sua idade: "))
    
    # Condição de parada do laço
    if idade < 0:
        print("Idade negativa digitada. Encerrando o programa.")
        break
    
    sexo = input("Digite seu sexo (M/F): ").upper()
    
    if sexo == 'M':
        print(f"Boa noite, Senhor. Sua idade é {idade}.")
    elif sexo == 'F':
        print(f"Boa noite, Senhora. Sua idade é {idade}.")
    else:
        print("Opção de sexo inválida.")
```

**Exercício 5:** Escreva um algoritmo que leia um valor e que imprima a quantidade de cédulas necessárias para pagar esse mesmo valor. Para simplificar, vamos trabalhar apenas com valores inteiros e com cédulas de R$ 100, R$ 50, R$ 20, R$ 10, R$ 5 e R$ 1.

```python
valor = int(input('Digite o valor em R$: '))

while True:
  if valor >= 100:
    cont100 = valor // 100
    valor = valor - cont100 * 100
    print(f'Notas de 100: {cont100}')
    if not valor:
      break
  
  if valor >= 50:
    cont50 = valor // 50
    valor = valor - cont50 * 50
    print(f'Notas de 50: {cont50}')
    if not valor:
      break

  if valor >= 20:
    cont20 = valor // 20
    valor = valor - cont20 * 20
    print(f'Notas de 20: {cont20}')
    if not valor:
      break

  if valor >= 10:
    cont10 = valor // 10
    valor = valor - cont10 * 10
    print(f'Notas de 10: {cont10}')
    if not valor:
      break

  if valor >= 5:
    cont5 = valor // 5
    valor = valor - cont5 * 5
    print(f'Notas de 5: {cont5}')
    if not valor:
      break
  
  if valor:
    cont1 = valor
    print(f'Notas de 1: {cont1}')
    break
```