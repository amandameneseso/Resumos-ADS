# Tuplas, listas, dicionários e strings

Ao longo desta abordagem, vamos aprender a trabalhar com **variáveis compostas em Python**, por meio dos três principais tipos existentes na linguagem: **tuplas, listas e dicionários**. Ao contrário das variáveis simples que armazenam um único dado (como uma "gaveta" em uma estante que contém um só item), as variáveis compostas são como uma "mochila" que pode carregar vários itens para a mesma finalidade.

Uma **estrutura de dados** é um conjunto de dados organizados de uma maneira específica. A maneira como os dados estão organizados na memória, como podem ser buscados, manipulados e acessados são o que definem e diferenciam as estruturas de dados. Desse modo, em linguagem Python temos majoritariamente três tipos de variáveis que armazenam diversos valores: tuplas, listas e dicionários. Todas apresentam características organizacionais distintas, e vamos investigar todas elas ao longo desta abordagem.

## 1. Tuplas

As tuplas são o **tipo mais simples de variável composta em Python**.

- **Características**: São **imutáveis** e **estáticas**. Uma vez criadas, não podem ser alteradas em tamanho ou conteúdo durante a execução do programa.
- **Sintaxe**: Os dados são separados por vírgulas e envolvidos por **parênteses** `()`.
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(mochila) # ('Machado', 'Camisa', 'Bacon', 'Abacate')
    ```
    
- Podemos **manipular e fatiar** a tupla da mesma maneira que aprendemos com strings, em momento anterior de nossos estudos. A seguir, encontramos um resumo com algumas possibilidades de fatiamento e manipulação de índices em tuplas:
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(mochila[0]) # print do elemento no índice 0
    print(mochila[2]) # print do elemento no índice 2
    print(mochila[0:2]) # print dos elementos nos índices 0 e 1 (0 até 2, não incluindo o 2)
    print(mochila[2:]) # print dos elementos a partir do índice 2
    print(mochila[-1]) # print do último
    ```
    
    Saída:
    
    ```python
    Machado
    Bacon
    ('Machado', 'Camisa')
    ('Bacon', 'Abacate')
    Abacate
    ```
    
- Lembrando que, como uma tupla é **imutável**, isso significa que não podemos realizar atribuições com tuplas. Se, por exemplo, tentarmos substituir o valor bacon por ovos (`mochila[2] = 'ovos'`), ocorre um erro: `‘tuple’ object does not support item assignment` (“objeto tupla não suporta atribuição”).
- Podemos fazer uma varredura (**iteração**) pelos elementos da tupla utilizando um laço de repetição. Como a tupla contém um tamanho finito, vamos trabalhar com o laço `for`. Para tuplas, o `for` é capaz de trabalhar mesmo sem a função `range`. Podemos somente fazer o laço a seguir que estaremos imprimindo todos os elementos da tupla na tela.
    
    ```python
    for item in mochila:
      print(item)
    ```
    
    Saída:
    
    ```python
    Machado
    Camisa
    Bacon
    Abacate
    ```
    
    A variável `item` está funcionando como um iterador nesse caso, e vai passar por todos os elementos da tupla realizando um `print` de cada um. Caso prefiramos, podemos também criar a varredura na tupla da maneira convencional, com `range`, mas para isso precisaremos inicialmente encontrar o tamanho da tupla usando a função `len`, e, em seguida, fazer o laço para esse tamanho. Veja a seguir:
    
    ```python
    tam = len(mochila)
    for item in range (0, tam, 1):
      print(mochila[item])
    ```
    
    - **`tam = len(mochila)`**: Primeiro, você obtém o número total de elementos na tupla, armazenando-o na variável `tam`.
    - **`for item in range (0, tam, 1):`**: O laço `for` é usado em combinação com a função `range()`. Isso faz com que a variável `item` assuma os valores de índice de 0 até o último índice da tupla. O `1` no final indica que o passo é unitário (o que já é o padrão).
    - **`print(mochila[item])`**: Dentro do laço, você usa a variável `item` para acessar cada elemento da tupla em sua posição correspondente.
    
    Saída:
    
    ```python
    Machado
    Camisa
    Bacon
    Abacate
    ```
    
    Aqui, utilizamos a abordagem de iterar sobre os **índices** da tupla, que é uma técnica comum em muitas linguagens de programação. Essa abordagem é útil quando você precisa do índice de cada elemento para alguma operação.
    
- **Concatenação**: Agora, vamos imaginar que vamos fazer um aprimoramento na mochila, inserindo mais dois espaços para itens. Se nossa variável da mochila contém quatro espaços e é uma tupla, ela não pode ter seu tamanho alterado. Porém, podemos criar uma nova variável de tupla que conterá a mochila antiga mais a atualização de tamanho. Podemos juntar ambas tuplas por intermédio de concatenação, assim como já aprendemos com strings.
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    upgrade = ('Queijo', 'Canivete')
    mochila_grande = mochila + upgrade
    
    print(mochila) # ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(upgrade) # ('Queijo', 'Canivete')
    print(mochila_grande) # ('Machado', 'Camisa', 'Bacon', 'Abacate', 'Queijo', 'Canivete')
    ```
    

### 1.1 Desempacotamento de parâmetros em funções

Podemos empregar tuplas para realizar um procedimento bastante poderoso em Python, o de desempacotar um parâmetro em uma função. 

Suponhamos que queremos realizar o somatório de diversos valores, porém não sabemos quantos valores serão somados. Pode ser que sejam somente 2, ou então 10, ou mesmo 100 números. Como criar uma função capaz de receber um número tão variável de parâmetros? Vejamos no exemplo a seguir o recurso do desempacotamento:

```python
def soma(*num):
 acumulador = 0
 print('Tupla: {}'.format(num))
 for i in num:
  acumulador += i
 return acumulador
 
print(f'Resultado: {soma(1,2)}')
print(f'Resultado: {soma(1,2,3,4,5,6,7,8,9)}')
```

Saída:

```python
Tupla: (1, 2)
Resultado: 3
Tupla: (1, 2, 3, 4, 5, 6, 7, 8, 9)
Resultado: 45
```

A função `soma(*num)` aceita um número variável de argumentos. O asterisco `*` antes do nome da variável (`num`) faz com que todos os argumentos passados para a função sejam "empacotados" em uma **tupla**.

**Explicação**:

1. `soma(*num)`: Quando chamamos `soma(1, 2)`, a tupla `num` se torna `(1, 2)`. Quando você chama `soma(1, 2, 3, 4, 5, 6, 7, 8, 9)`, a tupla `num` se torna `(1, 2, 3, 4, 5, 6, 7, 8, 9)`.
2. `acumulador = 0`: Uma variável é iniciada para acumular a soma dos números.
3. `for i in num:`: O laço de repetição percorre cada item da tupla `num`.
4. `acumulador += i`: A cada iteração, o valor atual da tupla (`i`) é somado ao `acumulador`.
5. `return acumulador`: Após o laço terminar, a função retorna o valor final do `acumulador`.

## 2. Listas

As listas são variáveis compostas **mutáveis**, permitindo a alteração de seus dados.

- **Características**: São **mutáveis** e **dinâmicas**.
- **Sintaxe**: Os dados são separados por vírgulas e envolvidos por **colchetes** `[]`.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    print(mochila) # ['Machado', 'Camisa', 'Bacon', 'Abacate']
    ```
    
- Exemplificando, vamos imaginar que o dono da mochila comeu o bacon e encontrou no caminho uma laranja. Ele deseja substituir a laranja pelo espaço que estava o bacon na sua mochila. Podemos fazer isso com uma estrutura do tipo **lista**.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    mochila[2] = 'Laranja'
    print(mochila) # ['Machado', 'Camisa', 'Laranja', 'Abacate']
    ```
    

### 2.1 Manipulando listas

Aprendemos a reatribuir um valor a um elemento diretamente, mas também podemos manipular listas utilizando **métodos**.

Nossa mochila atualmente contém 4 dados (índices 0 até 3). Se tentarmos adicionar um quinto item, fazendo `mochila[4] = ‘Ovos’`¸ não funcionará, pois não destinamos um espaço de memória para um quinto dado. Não podemos adicionar elementos dessa maneira na lista, então precisamos utilizar um método chamado de `append`, que se encarregará de alocar a memória no programa extra. Vejamos como utilizar a seguir:

- **Adicionar elementos**:
    - `append()`: Adiciona um elemento ao final da lista.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Laranja', 'Abacate']
    mochila.append('Ovos')
    print(mochila) # ['Machado', 'Camisa', 'Laranja', 'Abacate', 'Ovos']
    ```
    
    - `insert(índice, valor)`: Insere um elemento em uma posição específica da lista.
    
    ```python
    mochila.insert(1, 'Corda')
    print(mochila) # ['Machado', 'Corda', 'Camisa', 'Laranja', 'Abacate', 'Ovos']
    ```
    
- **Remover elementos**:
    - `del lista[índice]`: Remove um elemento pelo seu índice.
    
    ```python
    del mochila[2]
    print(mochila) # ['Machado', 'Corda', 'Laranja', 'Abacate', 'Ovos']
    ```
    
    - `remove(valor)`: Remove um elemento pelo seu valor específico.
    
    ```python
    mochila.remove('Ovos')
    print(mochila) # ['Machado', 'Corda', 'Laranja', 'Abacate']
    ```
    
    - `pop(índice)`: Remove um elemento pelo seu índice (ou o último se não passar nada).
    
    ```python
    mochila.pop(1)
    print(mochila) # ['Machado', 'Laranja', 'Abacate']
    ```
    
- **Métodos vs. Funções**: As listas são consideradas **objetos** de uma classe `list` em Python, e operações como `append`, `insert`, `remove` são chamadas de **métodos**.

>💡 **Saiba mais**
>    
>    Você observou que, nos exemplos anteriores, nos referimos ao append, insert, remove etc. por método ao invés de função? Por que essa alteração de nomenclatura?
>    
>    O que acontece é que uma lista em Python é, na verdade, um **objeto** de uma **classe** chamada de **list** dentro da linguagem. Os conceitos de objetos e classe fazem parte de um paradigma de programação, que chamamos de “programação orientada a objetos” (POO), em que programamos classes e objetos ao invés de somente manipular funções.
>    
>    Quando escrevemos:
>    
>    ```python
>    mochila = ['Machado', 'Camisa', 'Bacon']
>    ```
>    
>    O Python **não está criando só uma "caixinha de dados"**. Na verdade, ele está criando um **objeto** do tipo **list** (uma classe pronta da linguagem). Ou seja, **listas são objetos**, e objetos vêm com **funções próprias** que já sabem lidar com eles. Essas funções próprias são chamadas de **métodos**.
>    
>    **Diferença entre função e método:**
>    
>    - **Função**: existe sozinha e pode ser usada de forma independente.
>        
>        ```python
>        len(mochila)  # 'len' é uma função global que conta o tamanho
>        ```
>        
>    - **Método**: está "dentro" do objeto e só pode ser usado se você tiver esse objeto.
>        
>        ```python
>        mochila.append('Laranja')  # 'append' é um método das listas
>        ```
>        
>    
>    Aqui, `append` **só funciona porque a variável `mochila` é um objeto da classe `list`**.
>    
>    Se fosse uma string, por exemplo, não teria `append`, mas teria outros métodos próprios como `.upper()`, `.lower()`, etc. Isso acontece porque no Python, string também é um objeto (da classe `str`) — assim como listas, números, dicionários e praticamente tudo na linguagem. Cada classe tem seus próprios métodos.
>    
>    No paradigma de POO, acessamos uma função/métodos invocando o nome da variável, seguida de um ponto e, após o ponto, o nome da função. Por exemplo, como vimos:
>   
>    - `variável.método(parâmetro)`
>    - `mochila.append(‘Ovos’)`
>    
>    A quantidade de métodos disponíveis para manipularmos os objetos de listas, e mesmo tuplas e dicionários, é bastante grande e podem ser encontrados no link a seguir. Disponível em: [https://docs.python.org/pt-br/3/tutorial/datastructures.html](https://docs.python.org/pt-br/3/tutorial/datastructures.html).
    
### 2.2 Cópia de listas

A linguagem Python apresenta uma característica bastante interessante quando falamos de cópia de listas. Vamos observar o código a seguir.

```python
lista_original = [5, 7, 9, 11]
lista_referenciada = lista_original
print(lista_original)
print(lista_referenciada)

# saída:
# [5, 7, 9, 11]
# [5, 7, 9, 11]
```

Iniciamos o código criando uma lista, na linha 1. Na linha 2, estamos fazendo com que uma nova variável chamada `lista_refenciada` receba a mesma lista criada chamada `lista_original`. Como já era de se esperar, ao realizarmos o print de ambas, o resultado impresso é idêntico. Agora, vamos alterar o valor do índice zero da lista `lista_refenciada` e realizar o print de ambas na tela.

```python
lista_referenciada[0] = 2
print(lista_original)
print(lista_referenciada)

# saída:
# [2, 7, 9, 11]
# [2, 7, 9, 11]
```

Se alteramos somente a variável `lista_refenciada`, por que o print das duas listas saíram iguais? O que acontece aqui é que toda a lista é um objeto, se fizermos algo como `lista_referenciada = lista_original` em um objeto, somente estamos criando um segundo objeto com a mesma referência do primeiro e, portanto, caso alteremos um, estamos alterando o outro também (como se existisse uma conexão invisível entre eles). É como se estivéssemos dando mais um apelido para a variável `lista_original`, que agora atende por `lista_referenciada` também.

Desse modo, existe uma maneira de realmente criar uma cópia independe de cada lista. Vejamos a seguir como fazemos isso.

```python
lista_original = [5, 7, 9, 11]
lista_referenciada = lista_original[:]
print(lista_original)
print(lista_referenciada)

# saída:
# [5, 7, 9, 11]
# [5, 7, 9, 11]
```

É importante notar a alteração na linha 2. Ao invés de uma simples atribuição de uma variável na outra, fazemos `lista_referenciada = lista_original[:]`. Isso garante que uma cópia de `lista_original` é colocada em `lista_referenciada`. O uso dos dois pontos dentro dos colchetes garante a cópia integral. Caso queiramos copiar somente uma parte, podemos realizar um fatiamento de `lista_original`. Assim, qualquer manipulação feita com uma variável não afetará a outra, conforme visto no print a seguir, em que agora temos resultados diferentes.

```python
lista_referenciada[0] = 2
print(lista_original)
print(lista_referenciada)

# saída:
# [5, 7, 9, 11]
# [2, 7, 9, 11]
```

## 3. Strings e listas dentro de listas

Este tópico explora a **indexação dupla** e a criação de estruturas de dados mais complexas.

- **Indexação dupla em listas de strings**: Ao ter uma lista de strings, pode-se acessar caracteres individuais dentro de cada string usando dois índices. O primeiro índice se refere ao item na lista, e o segundo, ao caractere dentro da string.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    print(mochila[0][0])
    print(mochila[2][1])
    
    # saída:
    # M
    # a
    ```
    
- **Iteração dupla de índices**: Para percorrer tanto os itens da lista quanto os caracteres de cada string, utilizam-se **laços de repetição aninhados**.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    for item in mochila:
      for letra in item:
        print(letra, end='')
      print()
      
    # saída:
    # Machado
    # Camisa
    # Bacon
    # Abacate
    ```
    
    - O primeiro laço de repetição anda pelos itens da lista, enquanto o segundo, ainda dentro do primeiro, faz a varredura caractere por caractere daquele item. Assim, só avançamos para o próximo item quando terminado o atual. O print da linha 4 contém o parâmetro `end=’’` que impede que o print pule de linha a cada caractere impresso. Já o print da linha 5 está vazio propositalmente, servindo apenas para dar uma quebra de linha após uma palavra e outra.
- **Listas com listas (listas aninhadas)**: É possível criar uma lista cujos elementos são outras listas, permitindo armazenar dados heterogêneos (string, int, float) em uma única estrutura.
    
    Vamos imaginar uma situação em que devemos realizar o cadastro de uma lista de compras em um sistema. Cada produto comprado deverá ser registrado, com seu nome, quantidade e valor unitário. Para resolver esse problema, talvez a solução mais simples que venha na nossa mente seja a de criar três listas simples distintas, uma para cada tipo de dado. Porém, o Python nos possibilita ir além, pois podemos criar uma lista única em que, dentro de cada índice da lista, teremos outra lista contendo os campos de nome, quantidade e valor. Este é um caso de indexação dupla.
    
    Vejamos a seguir como implementar isso em Python. Vamos criar uma lista vazia e ir adicionando um produto por vez nela.
    
    ```python
    item = [] # lista temporária para armazenar os dados de um item
    mercado = [] # lista principal que vai guardar todos os itens
    
    for i in range(3): # repete 3 vezes (para cadastrar 3 itens)
      item.append(input('Digite o nome do item:')) # adiciona nome do item
      item.append(int(input('Digite a quantidade:'))) # adiciona quantidade (convertida para int)
      item.append(float(input('Digite o valor:'))) # adiciona valor (convertida para float)
      mercado.append(item[:]) # adiciona uma cópia de 'item' dentro da lista mercado
      item.clear() # limpa a lista item para ser reutilizada
    print(mercado)
    
    # saída:
    # Digite o nome do item:Cebola
    # Digite a quantidade:2
    # Digite o valor:0.99
    # Digite o nome do item:Tomate
    # Digite a quantidade:5
    # Digite o valor:0.89
    # Digite o nome do item:Saco de Arroz
    # Digite a quantidade:1
    # Digite o valor:5
    # [['Cebola', 2, 0.99], ['Tomate', 5, 0.89], ['Saco de Arroz', 1, 5.0]]
    ```
    
    Na linha 1 e linha 2, criamos duas listas vazias. A lista `item` é uma variável temporária que servirá para inserir a lista dentro da lista `mercado`. Dentro do laço de repetição, povoamos com leituras de dados via teclado a lista `item`, usando `append`. Colocamos nela o nome de um produto, sua quantidade e o valor unitário. Em seguida, na linha 8, inserimos uma cópia dela dentro da lista `mercado` (não se esquecer do `[:]`). Na linha 9, limpamos a lista `item` para que na próxima leitura de dados ela não contenha as informações que já inserimos no loop anterior. O print realizado nos mostra na tela que temos uma lista externa e, dentro dela, diversas pequenas listas separadas por vírgulas. Cada lista menor conterá uma trinca de valores heterogêneos: uma string, um int e um float.
    
    Uma maneira alternativa de solucionarmos o mesmo problema é, ao invés de criarmos duas listas, uma temporária menor e outra principal, criarmos somente a principal e variáveis simples para cada campo da lista. Vejamos a seguir como ficaria esse código.
    
    ```python
    mercado = []
    
    for i in range(3):
      nome = input('Digite o nome do item:')
      qtd = int(input('Digite a quantidade:'))
      valor = float(input('Digite o valor:'))
      mercado.append([nome, qtd, valor])
    print(mercado)
    ```
    
    Se inserirmos os mesmos dados nos campos input, a saída será igual à anterior.
    
    ```python
    [['Cebola', 2, 0.99], ['Tomate', 5, 0.89], ['Saco de Arroz', 1, 5.0]]
    ```
    
    Em vez de usar uma lista temporária, o código armazena os dados diretamente na lista `mercado` em uma única linha: `mercado.append([nome, quantidade, valor])`. A cada iteração, uma nova sublista com os dados do produto é criada e adicionada.
    

## 4. Dicionários

Os dicionários são estruturas de dados que utilizam **chaves** para referenciar os dados, em vez de índices numéricos.

- Baseiam-se na estrutura **hash**, que permite busca e inserção de dados via chaves (também chamadas de “palavras-chaves”).
- **Sintaxe**: São criados com a abertura de **chaves** `{}`. Cada entrada é um par `chave:valor`, onde a chave é separada do valor por dois pontos.
    
    ```python
    pessoa = {
        'nome': 'Maria',
        'idade': 25,
        'cidade': 'Teresina'
    }
    
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 25, 'cidade': 'Teresina'}
    ```
    
- **Acessando valores**: Podemos acessar os valores informando a chave:
    
    ```python
    print(pessoa['nome']) # Maria
    print(pessoa['idade']) # 25
    print(pessoa['cidade']) # Teresina
    ```
    
- **Alterando valores:**
    
    ```python
    pessoa['idade'] = 26
    print(pessoa['idade']) # 26
    ```
    
- **Adicionando novos pares:**
    
    ```python
    pessoa['profissão'] = 'Desenvolvedora'
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 26, 'cidade': 'Teresina', 'profissão': 'Desenvolvedora'}
    ```
    
- **Removendo pares:**
    
    ```python
    del pessoa['cidade']
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 26, 'profissão': 'Desenvolvedora'}
    ```
    
- **Métodos Importantes**:
    - `keys()`: Retorna todas as chaves do dicionário.
        
        ```python
        print(pessoa.keys())
        # dict_keys(['nome', 'idade', 'profissão'])
        ```
        
        Se quiser transformar em lista:
        
        ```python
        print(list(pessoa.keys()))
        # ['nome', 'idade', 'profissão']
        ```
        
        Também podemos realizar uma varredura pelos valores do dicionário com um laço:
        
        ```python
        for keys in pessoa.keys():
          print(keys)
        # nome
        # idade
        # profissão
        ```
        
    - `values()`: Retorna todos os valores do dicionário.
        
        ```python
        print(pessoa.values())
        # dict_values(['Maria', 26, 'Desenvolvedora'])
        
        # Transformando em lista:
        print(list(pessoa.values()))
        # ['Maria', 26, 'Desenvolvedora']
        
        # Iterando:
        for values in pessoa.values():
          print(values)
        # Maria
        # 26
        # Desenvolvedora
        ```
        
    - `items()`: Retorna todos os pares chave-valor.
        
        ```python
        print(pessoa.items())
        # dict_items([('nome', 'Maria'), ('idade', 26), ('profissão', 'Desenvolvedora')])
        
        # Transformando em lista:
        print(list(pessoa.items()))
        # [('nome', 'Maria'), ('idade', 26), ('profissão', 'Desenvolvedora')]
        
        # Iterando:
        for keys, values in pessoa.items():
          print(keys, values)
        # nome Maria
        # idade 26
        # profissão Desenvolvedora
        ```
        

### 4.1 Listas com dicionários

Uma lista, por si só, armazena uma sequência de itens. No entanto, esses itens podem ser outros tipos de dados, como dicionários. A principal vantagem de fazer isso é que podemos armazenar um conjunto de dados relacionados (como as informações de pessoas) em um único local, mas ainda manter a capacidade de adicionar mais itens à coleção.

```python
pessoas = []

pessoa1 = {
    'nome': 'Maria',
    'idade': 25,
    'cidade': 'Teresina'
}

pessoa2 = {
    'nome': 'João',
    'idade': 30,
    'cidade': 'São Paulo'
}

pessoa3 = {
    'nome': 'Ana',
    'idade': 22,
    'cidade': 'Recife'
}

pessoas = [pessoa1, pessoa2, pessoa3]
print(pessoas)
```

No exemplo, cada dicionário (`pessoa1`, `pessoa2`, `pessoa3`) representa um **registro completo** de uma pessoa. A **lista** `pessoas` funciona como um "banco de dados" ou uma coleção, onde cada índice armazena um desses dicionários.

É claro que a maneira apresentada anteriormente não é dinâmica o suficiente, pois só possibilita três cadastros. Podemos, então, criar uma inserção via teclado dos dados empregando um laço de repetição. Para isso, criamos uma estrutura de lista e uma de dicionário vazias. A lógica aqui é povoar o dicionário com dados do teclado e, em seguida, colocar o dicionário dentro da lista fazendo um `append`. Vejamos a seguir o código.

```python
pessoa = {} # cria um dicionário vazio (para armazenar os dados de cada pessoa)
pessoas = [] # cria uma lista vazia (para armazenar vários dicionários)

for i in range(3): # laço para cadastrar 3 pessoas
  pessoa['nome'] = input('Qual é o seu nome?')
  pessoa['idade'] = input('Qual é a sua idade?')
  pessoa['cidade'] = input('Onde você mora?')
  pessoas.append(pessoa.copy())
print('-' * 20)
for pessoa in pessoas: # percorre a lista de pessoas
  for chave, valor in pessoa.items():
    print(f'O campo {chave} tem o valor {valor}.') 
```

**Nota:** `pessoa.copy()` ****é fundamental. Se usássemos apenas `pessoas.append(pessoa)`, todas as posições da lista apontariam para o mesmo dicionário, e no final teríamos 3 cópias da última pessoa digitada. Com `copy()`, garantimos que cada item da lista seja um dicionário independente.

### 4.2 Dicionários com listas

Um dicionário pode ter listas como valores associados às suas chaves. Para preenchê-los, adiciona-se elementos diretamente às listas dentro do dicionário.

```python
pessoas = {
    'nome': ['Maria', 'João', 'Ana'],
    'idade': [25, 30, 22],
    'cidade': ['Teresina', 'São Paulo', 'Recife']
}
print(pessoas)
# {'nome': ['Maria', 'João', 'Ana'], 'idade': [25, 30, 22], 'cidade': ['Teresina', 'São Paulo', 'Recife']}
```

Também podemos criar a inserção dos dados no dicionário com listas via teclado, assim como víamos anteriormente:

```python
pessoas = {
    'nome': [],
    'idade': [],
    'cidade': []
}

for i in range(3):
    nome = input("Qual é o seu nome? ")
    idade = input("Qual é a sua idade? ")
    cidade = input("Onde você mora? ")

    pessoas['nome'].append(nome)
    pessoas['idade'].append(idade)
    pessoas['cidade'].append(cidade)

print('-' * 20)
print(pessoas)
```

Na linha 1, criamos a estrutura base do dicionário, já inserindo as palavras-chave e criando para cada uma delas uma lista completamente vazia. Em seguida, dentro do laço de repetição, fazemos a inserção dos dados em variáveis simples e, em seguida, fazemos um `append` na respectiva lista do dicionário.

## 5. Trabalhando com métodos em strings

- Strings, assim como tuplas, são **imutáveis**. Tentar alterar um caractere individualmente em uma string resultará em um `TypeError`.
    
    ```python
    string = "Python"
    string[0] = "J"  # TypeError: 'str' object does not support item assignment
    ```
    
- **Conversão para lista**: Pode-se converter uma string em uma lista de caracteres usando `list(string)`.
    
    ```python
    string = "Python"
    lista = list(string)
    print(lista)
    # ['P', 'y', 't', 'h', 'o', 'n']
    ```
    
    Converter lista de volta em string:
    
    ```python
    texto = ''.join(lista)
    print(texto)
    # Python
    ```
    
- **Verificação de caracteres**:
    - `startswith(prefixo)`: Verifica se a string começa com um prefixo.
    - `endswith(sufixo)`: Verifica se a string termina com um sufixo.
        
        ```python
        string = "Lógica de Programação e Algoritmos"
        print(string.startswith("Lógica"))    # True
        print(string.endswith("Algoritmos"))  # True
        ```
        
        Esses métodos são **case-sensitive:**
        
        ```python
        print(string.startswith("lógica"))    # False
        print(string.endswith("algoritmos"))  # False
        ```
        
- **Alterando maiúsculas e minúsculas:**
    - `upper()`: Converte todos os caracteres para maiúsculas.
    - `lower()`: Converte todos os caracteres para minúsculas.
        
        ```python
        print("Python".upper())  # PYTHON
        print("PYTHON".lower())  # python
        ```
        
- **Contagem de caracteres**:
    
    `count(substring)` conta as ocorrências de um caractere ou substring. Também é case-sensitive, podendo ser combinado com `lower()` para uma contagem inclusiva.
    
    ```python
    string = "banana"
    print(string.count("a"))  # 3
    ```
    
    Também é **case-sensitive:**
    
    ```python
    string = "Banana"
    print(string.count("b"))  # 0
    print(string.lower().count("b"))  # 1
    ```
    
- **Quebra de strings**:
    
    `split(delimitador)` divide uma string em uma lista de substrings, baseando-se em um caractere como divisor. O `split()` recebe como parâmetro qual caractere será usado para dividir. No exemplo, a string foi quebrada sempre que aparece um espaço.
    
    ```python
    frase = "Python é divertido"
    palavras = frase.split(" ")
    print(palavras)  # ['Python', 'é', 'divertido']
    ```
    
- **Substituição de strings**:
    
    `replace(antigo, novo, [quantidade])` substitui ocorrências de uma substring por outra. O terceiro parâmetro opcional pode limitar o número de substituições.
    
    ```python
    string = "Eu gosto de Java"
    novo = string.replace("Java", "Python")
    print(novo)  # Eu gosto de Python
    ```
    
    Com limite de substituições:
    
    ```python
    texto = "abc abc abc"
    novo = texto.replace("abc", "xyz", 2)
    print(novo)  # xyz xyz abc
    ```
    
- **Validação de tipos de dados em strings**: Python oferece vários métodos para verificar o conteúdo de uma string.
    
    ```python
    print("Python3".isalnum())  # True (só letras e números)
    print("Python".isalpha())   # True (só letras)
    print("123".isdigit())      # True (só dígitos)
    print("½".isnumeric())      # True (caractere numérico e caracteres matemáticos)
    print("HELLO".isupper())    # True (maiúsculas)
    print("hello".islower())    # True (minúsculas)
    print("   ".isspace())      # True (só espaços)
    print("Olá!".isprintable()) # True (todos imprimíveis)
    ```
    

![image.png](/images/divider2.png)

## Exercícios

**Exercício 1:** Crie um programa que contenha uma tupla com o nome de 10 linguagens de programação: Javascript, Rust, Swift, Python, Kotlin, Go, C#, Dart, Julia e Typescript. Em qual posição está a linguagem Python? Mostre na tela.

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

i = 0
while linguagens[i] != 'Python':
  i += 1

print(f'Encontramos Python na {i + 1}ª posição')
```

**Exercício 1.1:** Exibir a posição de todas as linguagens usando um loop.

for:

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

for i in range(len(linguagens)):
  print(f'{i+1}ª posição: {linguagens[i]}')

# O laço 'for' itera sobre o índice de cada elemento
# 'len(linguagens)' retorna o total de elementos (10)
# 'range(len(linguagens))' gera uma sequência de 0 a 9
```

while:

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

i = 0 # inicializa o contador de posição
while i < len(linguagens):
  print(f'{i+1}ª posição: {linguagens[i]}')
  i += 1 # incrementa o contador para a próxima iteração
  
# O laço 'while' continua enquanto o contador for menor que o tamanho da tupla
```

**Exercício 2:** Escreva uma função que contenha dois parâmetros. Essa função recebe como parâmetro uma string com uma mensagem a ser impressa na tela, e outro parâmetro como sendo uma quantidade arbitrária de números empacotados. Dentro da função, encontre o maior dentre todos os números recebidos e escreva na tela, dentro da função, a mensagem e o maior valor.

```python
# a função recebe como parâmetros uma string (msg) e um número arbitrário de argumentos empacotados em uma tupla (*num)

def func_maior(msg, *num):
  maior = num[0] # começa assumindo que o primeiro número é o maior
  for i in num: # itera sobre cada número na tupla 'num'
    if i > maior:
      maior = i # se o número atual 'i' for maior que o valor armazenado em 'maior', 'maior' é atualizado com o novo valor
  print(msg, maior)

func_maior('maior:', 8, 6, 4, 78, 56, 12, 9) # maior: 78
func_maior('maior:', 10, 2, 55, 34, 1) # maior: 55
```

**Exercício 3:** Escreva um algoritmo em Python que crie uma lista vazia e vá adicionando valores referentes a notas de um aluno nesta lista. Quando o usuário desejar parar de digitar notas (digitando um valor negativo, por exemplo), calcule a média das notas digitadas.

```python
notas = list() # cria uma lista vazia que vai armazenar as notas

x = float(input('Digite uma nota:')) # pede a primeira nota
while (x >= 0):
  notas.append(x) # enquanto o valor for >= 0, ele adiciona (append) a nota na lista (quando digitado um número negativo, o laço é interrompido)
  x = float(input('Digite uma nota:'))

soma = 0
for valores in notas: # percorre cada valor na lista 'notas'
  soma += valores # soma todas as notas

media = soma/len(notas) # calcula a media
print(notas)
print(f'Média das notas digitadas: {media}') 
```

**Exercício 4:** Escreva um algoritmo que leia o nome, a altura e o peso de pessoas, e armazene as informações em uma lista. O programa deve cadastrar um número indeterminado de dados e armazenar dentro da lista também o IMC da pessoa. Ao final do programa, imprima a lista completa e também:

- o total de cadastros;
- a pessoa com o maior IMC;
- a pessoa com o menor IMC.

O cálculo do IMC deve ser realizado empregando uma função lambda e é dado como: IMC = peso / (altura²).

```python
# cria uma lista vazia para armazenar todos os cadastros de pessoas
pessoas = []

# função lambda para o cálculo do IMC
imc = lambda peso, altura: peso / (altura * altura)

# inicia um laço de repetição infinito para permitir múltiplos cadastros
while True:
  # solicita os dados
  nome = input('Nome: ')
  altura = float(input('Altura (m): '))
  peso = int(input('Peso (kg): '))
  
  # calcula o IMC usando a função e armazena o resultado
  x = imc(peso, altura)
  
  # armazena os dados em uma lista
  # em seguida, adiciona esta lista à lista principal 'pessoas'
  pessoas.append([nome, altura, peso, x])
  
  # pergunta ao usuário se ele deseja continuar ou parar
  res = input('Deseja fazer mais um cadastro? [S/N] ')
  
  # se o usuário digitar 'N' ou 'n', o laço é interrompido
  if res in 'Nn':
    break

# exibe a lista completa de cadastros no final
print('\nCadastros: ', pessoas)

# exibe o número total de cadastros usando a função len()
print('Total de Cadastros: ', len(pessoas))

# inicializa as variáveis para encontrar o maior e menor IMC (com valores fixos funcionam para a maioria dos casos)
maior = 0
menor = 99

# laço para percorrer cada cadastro na lista 'pessoas'
for cadastro in pessoas:
  # verifica se o IMC do cadastro atual é o maior até agora
  if cadastro[3] > maior:
    maior = cadastro[3]
  
  # verifica se o IMC do cadastro atual é o menor até agora
  if cadastro[3] < menor:
    menor = cadastro[3]

# exibe os resultados do maior e menor IMC encontrados
print('\nMaior IMC:',maior)
print('Menor IMC:',menor)

```

**Exercício 5:** Dada uma lista contendo as notas de alunos em uma disciplina, escreva uma expressão para:

notas = [9, 7, 7, 10, 3, 9, 6, 6, 2]

1. Encontrar quantos alunos tiraram nota 7;
2. Alterar a última nota para 4;
3. Encontrar a maior nota;
4. Ordenar a lista de notas;
5. Média das notas

```python
print(f'{notas.count(7)} alunos tiraram nota 7.')
notas[-1] = 4
print(notas[-1])
print(max(notas))
notas.sort()
print(notas)
print(sum(notas) / len(notas))
```

**Exercício 6:** Escreva um programa que leia um número real do usuário e:

1. Calcule a raiz quadrada desse número.
2. Calcule o valor arredondado para cima (ceil) e para baixo (floor) desse número.
3. Calcule o valor absoluto do número.
4. Calcule o seno, cosseno e tangente do número (considerando que o número está em radianos).

```python
import math

num = float(input("Digite um número real: "))

# 1. raiz quadrada
raiz = math.sqrt(num)
print(f"Raiz quadrada: {raiz}")

# 2. arredondamento para cima e para baixo
print(f"Arredondamento para cima: {math.ceil(num)}")
print(f"Arredondamento para baixo: {math.floor(num)}")

# 3. valor absoluto
print(f"Valor absoluto: {math.fabs(num)}")

# 4. seno, Cosseno e Tangente
print(f"Seno: {math.sin(num)}")
print(f"Cosseno: {math.cos(num)}")
print(f"Tangente: {math.tan(num)}")
```

>💡 **Biblioteca math**
>    
>    A biblioteca **`math`** em Python é um módulo embutido que fornece acesso a funções matemáticas comuns, como operações trigonométricas, funções logarítmicas, potências e constantes.
>    
>    Para usar qualquer uma dessas funções, você deve primeiro importar a biblioteca no seu código.
>    
>    **Como usar a biblioteca `math`**
>    
>    O primeiro passo é sempre importar o módulo. A forma mais comum é usar a instrução `import`.
>    
>    ```python
>    import math
>    ```
>    
>    Ou podemos apenas importar funções específicas:
>    
>    ```python
>    from math import sqrt, sin
>    ```
>    
>    Depois de importada, você pode chamar as funções da biblioteca usando a sintaxe `math.funcao()`.
>    
>    Exemplos de funções úteis e como utilizá-las:
>    
>    - **`math.sqrt()` -** Calcula a **raiz quadrada** de um número.
>        
>        ```python
>        numero = 64
>        raiz_quadrada = math.sqrt(numero)
>        print(f"A raiz quadrada de {numero} é {raiz_quadrada}")
>        # A raiz quadrada de 64 é 8.0
>        ```
>        
>    - **`math.pow()` -** Eleva um número à **potência** de outro.
>        
>        ```python
>        base = 5
>        expoente = 3
>        potencia = math.pow(base, expoente)
>        print(f"{base} elevado a {expoente} é {potencia}")
>        # 5 elevado a 3 é 125.0
>        ```
>        
>        (Note que o operador `**` também faz a mesma coisa, como `5 ** 3`).
>        
>    - **`math.floor()` e `math.ceil()` - Arredondamento**`floor()` arredonda um número para o inteiro mais próximo **abaixo**. `ceil()` arredonda um número para o inteiro mais próximo **acima**.
>        
>        ```python
>        valor = 4.7
>        abaixo = math.floor(valor)
>        acima = math.ceil(valor)
>        print(f"O número {valor} arredondado para baixo é {abaixo}")
>        print(f"O número {valor} arredondado para cima é {acima}")
>        # O número 4.7 arredondado para baixo é 4
>        # O número 4.7 arredondado para cima é 5
>        ```
>        
>    - **Constantes:** A biblioteca `math` também inclui constantes matemáticas importantes, como o valor de pi (`pi`) e a base do logaritmo natural (`e`).
>        
>        ```python
>        print(f"O valor de Pi é: {math.pi}")
>        print(f"O valor de E é: {math.e}")
>        # O valor de Pi é: 3.141592653589793
>        # O valor de E é: 2.718281828459045
>        ```
>        
>    - Algumas funções importantes:
>        
>        
>        | Função | Descrição |
>        | --- | --- |
>        | `math.sqrt(x)` | Raiz quadrada de x |
>        | `math.pow(x, y)` | x elevado à potência y |
>        | `math.ceil(x)` | Arredonda x para cima |
>        | `math.floor(x)` | Arredonda x para baixo |
>        | `math.fabs(x)` | Valor absoluto de x |
>        | `math.sin(x)` | Seno de x (x em radianos) |
>        | `math.cos(x)` | Cosseno de x (x em radianos) |
>        | `math.tan(x)` | Tangente de x (x em radianos) |
>        | `math.log(x)` | Logaritmo natural (base e) |
>        | `math.log10(x)` | Logaritmo na base 10 |
>        | `math.factorial(x)` | Fatorial de x |
>        | `math.pi` | Constante π |
>        | `math.e` | Constante e (base do logaritmo natural) |

**Exercício 7:** Escreva um programa em Python que leia o nome de um aluno e três notas. Armazene em um dicionário o nome e a média aritmética da nota. Ainda, armazene no dicionário a situação do aluno:

- Média >= 7, aprovado;
- Média < 7 e >= 5, em exame;
- Média < 5, reprovado.

Apresente tudo na tela ao final do programa em um formato organizado.

```python
# criando um dicionário vazio chamado 'aluno'
aluno = {}

# coletando o nome do aluno e armazenando no dicionário
aluno['nome'] = input('Qual o nome do aluno?')

# coletando as três notas do aluno
n1 = float(input('Qual a primeira nota?'))
n2 = float(input('Qual a segunda nota?'))
n3 = float(input('Qual a terceira nota?'))

# calculando a média das 3 notas e salvando no dicionário
aluno['media'] = (n1 + n2 + n3) / 3

# verificando a situação do aluno de acordo com a média
if aluno['media'] >= 7:
  aluno['status'] = 'A' # aprovado
elif aluno['media'] >= 5 and aluno['media'] < 7:
  aluno['status'] = 'E' # em exame
else:
  aluno['status'] = 'R' # reprovado

# exibindo os dados
for chave, valor in aluno.items():
  print(f'{chave} = {valor}')
```