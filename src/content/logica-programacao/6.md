# Tuplas, listas, dicion√°rios e strings

Ao longo desta abordagem, vamos aprender a trabalhar com **vari√°veis compostas em Python**, por meio dos tr√™s principais tipos existentes na linguagem: **tuplas, listas e dicion√°rios**. Ao contr√°rio das vari√°veis simples que armazenam um √∫nico dado (como uma "gaveta" em uma estante que cont√©m um s√≥ item), as vari√°veis compostas s√£o como uma "mochila" que pode carregar v√°rios itens para a mesma finalidade.

Uma **estrutura de dados** √© um conjunto de dados organizados de uma maneira espec√≠fica. A maneira como os dados est√£o organizados na mem√≥ria, como podem ser buscados, manipulados e acessados s√£o o que definem e diferenciam as estruturas de dados. Desse modo, em linguagem Python temos majoritariamente tr√™s tipos de vari√°veis que armazenam diversos valores: tuplas, listas e dicion√°rios. Todas apresentam caracter√≠sticas organizacionais distintas, e vamos investigar todas elas ao longo desta abordagem.

## 1. Tuplas

As tuplas s√£o o **tipo mais simples de vari√°vel composta em Python**.

- **Caracter√≠sticas**: S√£o **imut√°veis** e **est√°ticas**. Uma vez criadas, n√£o podem ser alteradas em tamanho ou conte√∫do durante a execu√ß√£o do programa.
- **Sintaxe**: Os dados s√£o separados por v√≠rgulas e envolvidos por **par√™nteses** `()`.
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(mochila) # ('Machado', 'Camisa', 'Bacon', 'Abacate')
    ```
    
- Podemos **manipular e fatiar** a tupla da mesma maneira que aprendemos com strings, em momento anterior de nossos estudos. A seguir, encontramos um resumo com algumas possibilidades de fatiamento e manipula√ß√£o de √≠ndices em tuplas:
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(mochila[0]) # print do elemento no √≠ndice 0
    print(mochila[2]) # print do elemento no √≠ndice 2
    print(mochila[0:2]) # print dos elementos nos √≠ndices 0 e 1 (0 at√© 2, n√£o incluindo o 2)
    print(mochila[2:]) # print dos elementos a partir do √≠ndice 2
    print(mochila[-1]) # print do √∫ltimo
    ```
    
    Sa√≠da:
    
    ```python
    Machado
    Bacon
    ('Machado', 'Camisa')
    ('Bacon', 'Abacate')
    Abacate
    ```
    
- Lembrando que, como uma tupla √© **imut√°vel**, isso significa que n√£o podemos realizar atribui√ß√µes com tuplas. Se, por exemplo, tentarmos substituir o valor bacon por ovos (`mochila[2] = 'ovos'`), ocorre um erro: `‚Äòtuple‚Äô object does not support item assignment` (‚Äúobjeto tupla n√£o suporta atribui√ß√£o‚Äù).
- Podemos fazer uma varredura (**itera√ß√£o**) pelos elementos da tupla utilizando um la√ßo de repeti√ß√£o. Como a tupla cont√©m um tamanho finito, vamos trabalhar com o la√ßo `for`. Para tuplas, o `for` √© capaz de trabalhar mesmo sem a fun√ß√£o `range`. Podemos somente fazer o la√ßo a seguir que estaremos imprimindo todos os elementos da tupla na tela.
    
    ```python
    for item in mochila:
      print(item)
    ```
    
    Sa√≠da:
    
    ```python
    Machado
    Camisa
    Bacon
    Abacate
    ```
    
    A vari√°vel `item` est√° funcionando como um iterador nesse caso, e vai passar por todos os elementos da tupla realizando um `print` de cada um. Caso prefiramos, podemos tamb√©m criar a varredura na tupla da maneira convencional, com `range`, mas para isso precisaremos inicialmente encontrar o tamanho da tupla usando a fun√ß√£o `len`, e, em seguida, fazer o la√ßo para esse tamanho. Veja a seguir:
    
    ```python
    tam = len(mochila)
    for item in range (0, tam, 1):
      print(mochila[item])
    ```
    
    - **`tam = len(mochila)`**: Primeiro, voc√™ obt√©m o n√∫mero total de elementos na tupla, armazenando-o na vari√°vel `tam`.
    - **`for item in range (0, tam, 1):`**: O la√ßo `for` √© usado em combina√ß√£o com a fun√ß√£o `range()`. Isso faz com que a vari√°vel `item` assuma os valores de √≠ndice de 0 at√© o √∫ltimo √≠ndice da tupla. O `1` no final indica que o passo √© unit√°rio (o que j√° √© o padr√£o).
    - **`print(mochila[item])`**: Dentro do la√ßo, voc√™ usa a vari√°vel `item` para acessar cada elemento da tupla em sua posi√ß√£o correspondente.
    
    Sa√≠da:
    
    ```python
    Machado
    Camisa
    Bacon
    Abacate
    ```
    
    Aqui, utilizamos a abordagem de iterar sobre os **√≠ndices** da tupla, que √© uma t√©cnica comum em muitas linguagens de programa√ß√£o. Essa abordagem √© √∫til quando voc√™ precisa do √≠ndice de cada elemento para alguma opera√ß√£o.
    
- **Concatena√ß√£o**: Agora, vamos imaginar que vamos fazer um aprimoramento na mochila, inserindo mais dois espa√ßos para itens. Se nossa vari√°vel da mochila cont√©m quatro espa√ßos e √© uma tupla, ela n√£o pode ter seu tamanho alterado. Por√©m, podemos criar uma nova vari√°vel de tupla que conter√° a mochila antiga mais a atualiza√ß√£o de tamanho. Podemos juntar ambas tuplas por interm√©dio de concatena√ß√£o, assim como j√° aprendemos com strings.
    
    ```python
    mochila = ('Machado', 'Camisa', 'Bacon', 'Abacate')
    upgrade = ('Queijo', 'Canivete')
    mochila_grande = mochila + upgrade
    
    print(mochila) # ('Machado', 'Camisa', 'Bacon', 'Abacate')
    print(upgrade) # ('Queijo', 'Canivete')
    print(mochila_grande) # ('Machado', 'Camisa', 'Bacon', 'Abacate', 'Queijo', 'Canivete')
    ```
    

### 1.1 Desempacotamento de par√¢metros em fun√ß√µes

Podemos empregar tuplas para realizar um procedimento bastante poderoso em Python, o de desempacotar um par√¢metro em uma fun√ß√£o. 

Suponhamos que queremos realizar o somat√≥rio de diversos valores, por√©m n√£o sabemos quantos valores ser√£o somados. Pode ser que sejam somente 2, ou ent√£o 10, ou mesmo 100 n√∫meros. Como criar uma fun√ß√£o capaz de receber um n√∫mero t√£o vari√°vel de par√¢metros? Vejamos no exemplo a seguir o recurso do desempacotamento:

```python
def soma(*num):
 acumulador = 0
 print('Tupla: {}'.format(num))
 for i in num:
  acumulador += i
 return acumulador
 
print(f'Resultado: {soma(1,2)}')
print(f'Resultado: {soma(1,2,3,4,5,6,7,8,9)}')
```

Sa√≠da:

```python
Tupla: (1, 2)
Resultado: 3
Tupla: (1, 2, 3, 4, 5, 6, 7, 8, 9)
Resultado: 45
```

A fun√ß√£o `soma(*num)` aceita um n√∫mero vari√°vel de argumentos. O asterisco `*` antes do nome da vari√°vel (`num`) faz com que todos os argumentos passados para a fun√ß√£o sejam "empacotados" em uma **tupla**.

**Explica√ß√£o**:

1. `soma(*num)`: Quando chamamos `soma(1, 2)`, a tupla `num` se torna `(1, 2)`. Quando voc√™ chama `soma(1, 2, 3, 4, 5, 6, 7, 8, 9)`, a tupla `num` se torna `(1, 2, 3, 4, 5, 6, 7, 8, 9)`.
2. `acumulador = 0`: Uma vari√°vel √© iniciada para acumular a soma dos n√∫meros.
3. `for i in num:`: O la√ßo de repeti√ß√£o percorre cada item da tupla `num`.
4. `acumulador += i`: A cada itera√ß√£o, o valor atual da tupla (`i`) √© somado ao `acumulador`.
5. `return acumulador`: Ap√≥s o la√ßo terminar, a fun√ß√£o retorna o valor final do `acumulador`.

## 2. Listas

As listas s√£o vari√°veis compostas **mut√°veis**, permitindo a altera√ß√£o de seus dados.

- **Caracter√≠sticas**: S√£o **mut√°veis** e **din√¢micas**.
- **Sintaxe**: Os dados s√£o separados por v√≠rgulas e envolvidos por **colchetes** `[]`.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    print(mochila) # ['Machado', 'Camisa', 'Bacon', 'Abacate']
    ```
    
- Exemplificando, vamos imaginar que o dono da mochila comeu o bacon e encontrou no caminho uma laranja. Ele deseja substituir a laranja pelo espa√ßo que estava o bacon na sua mochila. Podemos fazer isso com uma estrutura do tipo **lista**.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    mochila[2] = 'Laranja'
    print(mochila) # ['Machado', 'Camisa', 'Laranja', 'Abacate']
    ```
    

### 2.1 Manipulando listas

Aprendemos a reatribuir um valor a um elemento diretamente, mas tamb√©m podemos manipular listas utilizando **m√©todos**.

Nossa mochila atualmente cont√©m 4 dados (√≠ndices 0 at√© 3). Se tentarmos adicionar um quinto item, fazendo `mochila[4] = ‚ÄòOvos‚Äô`¬∏ n√£o funcionar√°, pois n√£o destinamos um espa√ßo de mem√≥ria para um quinto dado. N√£o podemos adicionar elementos dessa maneira na lista, ent√£o precisamos utilizar um m√©todo chamado de `append`, que se encarregar√° de alocar a mem√≥ria no programa extra. Vejamos como utilizar a seguir:

- **Adicionar elementos**:
    - `append()`: Adiciona um elemento ao final da lista.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Laranja', 'Abacate']
    mochila.append('Ovos')
    print(mochila) # ['Machado', 'Camisa', 'Laranja', 'Abacate', 'Ovos']
    ```
    
    - `insert(√≠ndice, valor)`: Insere um elemento em uma posi√ß√£o espec√≠fica da lista.
    
    ```python
    mochila.insert(1, 'Corda')
    print(mochila) # ['Machado', 'Corda', 'Camisa', 'Laranja', 'Abacate', 'Ovos']
    ```
    
- **Remover elementos**:
    - `del lista[√≠ndice]`: Remove um elemento pelo seu √≠ndice.
    
    ```python
    del mochila[2]
    print(mochila) # ['Machado', 'Corda', 'Laranja', 'Abacate', 'Ovos']
    ```
    
    - `remove(valor)`: Remove um elemento pelo seu valor espec√≠fico.
    
    ```python
    mochila.remove('Ovos')
    print(mochila) # ['Machado', 'Corda', 'Laranja', 'Abacate']
    ```
    
    - `pop(√≠ndice)`: Remove um elemento pelo seu √≠ndice (ou o √∫ltimo se n√£o passar nada).
    
    ```python
    mochila.pop(1)
    print(mochila) # ['Machado', 'Laranja', 'Abacate']
    ```
    
- **M√©todos vs. Fun√ß√µes**: As listas s√£o consideradas **objetos** de uma classe `list` em Python, e opera√ß√µes como `append`, `insert`, `remove` s√£o chamadas de **m√©todos**.

>üí° **Saiba mais**
>    
>    Voc√™ observou que, nos exemplos anteriores, nos referimos ao append, insert, remove etc. por m√©todo ao inv√©s de fun√ß√£o? Por que essa altera√ß√£o de nomenclatura?
>    
>    O que acontece √© que uma lista em Python √©, na verdade, um **objeto** de uma **classe** chamada de **list** dentro da linguagem. Os conceitos de objetos e classe fazem parte de um paradigma de programa√ß√£o, que chamamos de ‚Äúprograma√ß√£o orientada a objetos‚Äù (POO), em que programamos classes e objetos ao inv√©s de somente manipular fun√ß√µes.
>    
>    Quando escrevemos:
>    
>    ```python
>    mochila = ['Machado', 'Camisa', 'Bacon']
>    ```
>    
>    O Python **n√£o est√° criando s√≥ uma "caixinha de dados"**. Na verdade, ele est√° criando um **objeto** do tipo **list** (uma classe pronta da linguagem). Ou seja, **listas s√£o objetos**, e objetos v√™m com **fun√ß√µes pr√≥prias** que j√° sabem lidar com eles. Essas fun√ß√µes pr√≥prias s√£o chamadas de **m√©todos**.
>    
>    **Diferen√ßa entre fun√ß√£o e m√©todo:**
>    
>    - **Fun√ß√£o**: existe sozinha e pode ser usada de forma independente.
>        
>        ```python
>        len(mochila)  # 'len' √© uma fun√ß√£o global que conta o tamanho
>        ```
>        
>    - **M√©todo**: est√° "dentro" do objeto e s√≥ pode ser usado se voc√™ tiver esse objeto.
>        
>        ```python
>        mochila.append('Laranja')  # 'append' √© um m√©todo das listas
>        ```
>        
>    
>    Aqui, `append` **s√≥ funciona porque a vari√°vel `mochila` √© um objeto da classe `list`**.
>    
>    Se fosse uma string, por exemplo, n√£o teria `append`, mas teria outros m√©todos pr√≥prios como `.upper()`, `.lower()`, etc. Isso acontece porque no Python, string tamb√©m √© um objeto (da classe `str`) ‚Äî assim como listas, n√∫meros, dicion√°rios e praticamente tudo na linguagem. Cada classe tem seus pr√≥prios m√©todos.
>    
>    No paradigma de POO, acessamos uma fun√ß√£o/m√©todos invocando o nome da vari√°vel, seguida de um ponto e, ap√≥s o ponto, o nome da fun√ß√£o. Por exemplo, como vimos:
>   
>    - `vari√°vel.m√©todo(par√¢metro)`
>    - `mochila.append(‚ÄòOvos‚Äô)`
>    
>    A quantidade de m√©todos dispon√≠veis para manipularmos os objetos de listas, e mesmo tuplas e dicion√°rios, √© bastante grande e podem ser encontrados no link a seguir. Dispon√≠vel em: [https://docs.python.org/pt-br/3/tutorial/datastructures.html](https://docs.python.org/pt-br/3/tutorial/datastructures.html).
    
### 2.2 C√≥pia de listas

A linguagem Python apresenta uma caracter√≠stica bastante interessante quando falamos de c√≥pia de listas. Vamos observar o c√≥digo a seguir.

```python
lista_original = [5, 7, 9, 11]
lista_referenciada = lista_original
print(lista_original)
print(lista_referenciada)

# sa√≠da:
# [5, 7, 9, 11]
# [5, 7, 9, 11]
```

Iniciamos o c√≥digo criando uma lista, na linha 1. Na linha 2, estamos fazendo com que uma nova vari√°vel chamada `lista_refenciada` receba a mesma lista criada chamada `lista_original`. Como j√° era de se esperar, ao realizarmos o print de ambas, o resultado impresso √© id√™ntico. Agora, vamos alterar o valor do √≠ndice zero da lista `lista_refenciada` e realizar o print de ambas na tela.

```python
lista_referenciada[0] = 2
print(lista_original)
print(lista_referenciada)

# sa√≠da:
# [2, 7, 9, 11]
# [2, 7, 9, 11]
```

Se alteramos somente a vari√°vel `lista_refenciada`, por que o print das duas listas sa√≠ram iguais? O que acontece aqui √© que toda a lista √© um objeto, se fizermos algo como `lista_referenciada = lista_original` em um objeto, somente estamos criando um segundo objeto com a mesma refer√™ncia do primeiro e, portanto, caso alteremos um, estamos alterando o outro tamb√©m (como se existisse uma conex√£o invis√≠vel entre eles). √â como se estiv√©ssemos dando mais um apelido para a vari√°vel `lista_original`, que agora atende por `lista_referenciada` tamb√©m.

Desse modo, existe uma maneira de realmente criar uma c√≥pia independe de cada lista. Vejamos a seguir como fazemos isso.

```python
lista_original = [5, 7, 9, 11]
lista_referenciada = lista_original[:]
print(lista_original)
print(lista_referenciada)

# sa√≠da:
# [5, 7, 9, 11]
# [5, 7, 9, 11]
```

√â importante notar a altera√ß√£o na linha 2. Ao inv√©s de uma simples atribui√ß√£o de uma vari√°vel na outra, fazemos `lista_referenciada = lista_original[:]`. Isso garante que uma c√≥pia de `lista_original` √© colocada em `lista_referenciada`. O uso dos dois pontos dentro dos colchetes garante a c√≥pia integral. Caso queiramos copiar somente uma parte, podemos realizar um fatiamento de `lista_original`. Assim, qualquer manipula√ß√£o feita com uma vari√°vel n√£o afetar√° a outra, conforme visto no print a seguir, em que agora temos resultados diferentes.

```python
lista_referenciada[0] = 2
print(lista_original)
print(lista_referenciada)

# sa√≠da:
# [5, 7, 9, 11]
# [2, 7, 9, 11]
```

## 3. Strings e listas dentro de listas

Este t√≥pico explora a **indexa√ß√£o dupla** e a cria√ß√£o de estruturas de dados mais complexas.

- **Indexa√ß√£o dupla em listas de strings**: Ao ter uma lista de strings, pode-se acessar caracteres individuais dentro de cada string usando dois √≠ndices. O primeiro √≠ndice se refere ao item na lista, e o segundo, ao caractere dentro da string.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    print(mochila[0][0])
    print(mochila[2][1])
    
    # sa√≠da:
    # M
    # a
    ```
    
- **Itera√ß√£o dupla de √≠ndices**: Para percorrer tanto os itens da lista quanto os caracteres de cada string, utilizam-se **la√ßos de repeti√ß√£o aninhados**.
    
    ```python
    mochila = ['Machado', 'Camisa', 'Bacon', 'Abacate']
    for item in mochila:
      for letra in item:
        print(letra, end='')
      print()
      
    # sa√≠da:
    # Machado
    # Camisa
    # Bacon
    # Abacate
    ```
    
    - O primeiro la√ßo de repeti√ß√£o anda pelos itens da lista, enquanto o segundo, ainda dentro do primeiro, faz a varredura caractere por caractere daquele item. Assim, s√≥ avan√ßamos para o pr√≥ximo item quando terminado o atual. O print da linha 4 cont√©m o par√¢metro `end=‚Äô‚Äô` que impede que o print pule de linha a cada caractere impresso. J√° o print da linha 5 est√° vazio propositalmente, servindo apenas para dar uma quebra de linha ap√≥s uma palavra e outra.
- **Listas com listas (listas aninhadas)**: √â poss√≠vel criar uma lista cujos elementos s√£o outras listas, permitindo armazenar dados heterog√™neos (string, int, float) em uma √∫nica estrutura.
    
    Vamos imaginar uma situa√ß√£o em que devemos realizar o cadastro de uma lista de compras em um sistema. Cada produto comprado dever√° ser registrado, com seu nome, quantidade e valor unit√°rio. Para resolver esse problema, talvez a solu√ß√£o mais simples que venha na nossa mente seja a de criar tr√™s listas simples distintas, uma para cada tipo de dado. Por√©m, o Python nos possibilita ir al√©m, pois podemos criar uma lista √∫nica em que, dentro de cada √≠ndice da lista, teremos outra lista contendo os campos de nome, quantidade e valor. Este √© um caso de indexa√ß√£o dupla.
    
    Vejamos a seguir como implementar isso em Python. Vamos criar uma lista vazia e ir adicionando um produto por vez nela.
    
    ```python
    item = [] # lista tempor√°ria para armazenar os dados de um item
    mercado = [] # lista principal que vai guardar todos os itens
    
    for i in range(3): # repete 3 vezes (para cadastrar 3 itens)
      item.append(input('Digite o nome do item:')) # adiciona nome do item
      item.append(int(input('Digite a quantidade:'))) # adiciona quantidade (convertida para int)
      item.append(float(input('Digite o valor:'))) # adiciona valor (convertida para float)
      mercado.append(item[:]) # adiciona uma c√≥pia de 'item' dentro da lista mercado
      item.clear() # limpa a lista item para ser reutilizada
    print(mercado)
    
    # sa√≠da:
    # Digite o nome do item:Cebola
    # Digite a quantidade:2
    # Digite o valor:0.99
    # Digite o nome do item:Tomate
    # Digite a quantidade:5
    # Digite o valor:0.89
    # Digite o nome do item:Saco de Arroz
    # Digite a quantidade:1
    # Digite o valor:5
    # [['Cebola', 2, 0.99], ['Tomate', 5, 0.89], ['Saco de Arroz', 1, 5.0]]
    ```
    
    Na linha 1 e linha 2, criamos duas listas vazias. A lista `item` √© uma vari√°vel tempor√°ria que servir√° para inserir a lista dentro da lista `mercado`. Dentro do la√ßo de repeti√ß√£o, povoamos com leituras de dados via teclado a lista `item`, usando `append`. Colocamos nela o nome de um produto, sua quantidade e o valor unit√°rio. Em seguida, na linha 8, inserimos uma c√≥pia dela dentro da lista `mercado` (n√£o se esquecer do `[:]`). Na linha 9, limpamos a lista `item` para que na pr√≥xima leitura de dados ela n√£o contenha as informa√ß√µes que j√° inserimos no loop anterior. O print realizado nos mostra na tela que temos uma lista externa e, dentro dela, diversas pequenas listas separadas por v√≠rgulas. Cada lista menor conter√° uma trinca de valores heterog√™neos: uma string, um int e um float.
    
    Uma maneira alternativa de solucionarmos o mesmo problema √©, ao inv√©s de criarmos duas listas, uma tempor√°ria menor e outra principal, criarmos somente a principal e vari√°veis simples para cada campo da lista. Vejamos a seguir como ficaria esse c√≥digo.
    
    ```python
    mercado = []
    
    for i in range(3):
      nome = input('Digite o nome do item:')
      qtd = int(input('Digite a quantidade:'))
      valor = float(input('Digite o valor:'))
      mercado.append([nome, qtd, valor])
    print(mercado)
    ```
    
    Se inserirmos os mesmos dados nos campos input, a sa√≠da ser√° igual √† anterior.
    
    ```python
    [['Cebola', 2, 0.99], ['Tomate', 5, 0.89], ['Saco de Arroz', 1, 5.0]]
    ```
    
    Em vez de usar uma lista tempor√°ria, o c√≥digo armazena os dados diretamente na lista `mercado` em uma √∫nica linha: `mercado.append([nome, quantidade, valor])`. A cada itera√ß√£o, uma nova sublista com os dados do produto √© criada e adicionada.
    

## 4. Dicion√°rios

Os dicion√°rios s√£o estruturas de dados que utilizam **chaves** para referenciar os dados, em vez de √≠ndices num√©ricos.

- Baseiam-se na estrutura **hash**, que permite busca e inser√ß√£o de dados via chaves (tamb√©m chamadas de ‚Äúpalavras-chaves‚Äù).
- **Sintaxe**: S√£o criados com a abertura de **chaves** `{}`. Cada entrada √© um par `chave:valor`, onde a chave √© separada do valor por dois pontos.
    
    ```python
    pessoa = {
        'nome': 'Maria',
        'idade': 25,
        'cidade': 'Teresina'
    }
    
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 25, 'cidade': 'Teresina'}
    ```
    
- **Acessando valores**: Podemos acessar os valores informando a chave:
    
    ```python
    print(pessoa['nome']) # Maria
    print(pessoa['idade']) # 25
    print(pessoa['cidade']) # Teresina
    ```
    
- **Alterando valores:**
    
    ```python
    pessoa['idade'] = 26
    print(pessoa['idade']) # 26
    ```
    
- **Adicionando novos pares:**
    
    ```python
    pessoa['profiss√£o'] = 'Desenvolvedora'
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 26, 'cidade': 'Teresina', 'profiss√£o': 'Desenvolvedora'}
    ```
    
- **Removendo pares:**
    
    ```python
    del pessoa['cidade']
    print(pessoa)
    
    # {'nome': 'Maria', 'idade': 26, 'profiss√£o': 'Desenvolvedora'}
    ```
    
- **M√©todos Importantes**:
    - `keys()`: Retorna todas as chaves do dicion√°rio.
        
        ```python
        print(pessoa.keys())
        # dict_keys(['nome', 'idade', 'profiss√£o'])
        ```
        
        Se quiser transformar em lista:
        
        ```python
        print(list(pessoa.keys()))
        # ['nome', 'idade', 'profiss√£o']
        ```
        
        Tamb√©m podemos realizar uma varredura pelos valores do dicion√°rio com um la√ßo:
        
        ```python
        for keys in pessoa.keys():
          print(keys)
        # nome
        # idade
        # profiss√£o
        ```
        
    - `values()`: Retorna todos os valores do dicion√°rio.
        
        ```python
        print(pessoa.values())
        # dict_values(['Maria', 26, 'Desenvolvedora'])
        
        # Transformando em lista:
        print(list(pessoa.values()))
        # ['Maria', 26, 'Desenvolvedora']
        
        # Iterando:
        for values in pessoa.values():
          print(values)
        # Maria
        # 26
        # Desenvolvedora
        ```
        
    - `items()`: Retorna todos os pares chave-valor.
        
        ```python
        print(pessoa.items())
        # dict_items([('nome', 'Maria'), ('idade', 26), ('profiss√£o', 'Desenvolvedora')])
        
        # Transformando em lista:
        print(list(pessoa.items()))
        # [('nome', 'Maria'), ('idade', 26), ('profiss√£o', 'Desenvolvedora')]
        
        # Iterando:
        for keys, values in pessoa.items():
          print(keys, values)
        # nome Maria
        # idade 26
        # profiss√£o Desenvolvedora
        ```
        

### 4.1 Listas com dicion√°rios

Uma lista, por si s√≥, armazena uma sequ√™ncia de itens. No entanto, esses itens podem ser outros tipos de dados, como dicion√°rios. A principal vantagem de fazer isso √© que podemos armazenar um conjunto de dados relacionados (como as informa√ß√µes de pessoas) em um √∫nico local, mas ainda manter a capacidade de adicionar mais itens √† cole√ß√£o.

```python
pessoas = []

pessoa1 = {
    'nome': 'Maria',
    'idade': 25,
    'cidade': 'Teresina'
}

pessoa2 = {
    'nome': 'Jo√£o',
    'idade': 30,
    'cidade': 'S√£o Paulo'
}

pessoa3 = {
    'nome': 'Ana',
    'idade': 22,
    'cidade': 'Recife'
}

pessoas = [pessoa1, pessoa2, pessoa3]
print(pessoas)
```

No exemplo, cada dicion√°rio (`pessoa1`, `pessoa2`, `pessoa3`) representa um **registro completo** de uma pessoa. A **lista** `pessoas` funciona como um "banco de dados" ou uma cole√ß√£o, onde cada √≠ndice armazena um desses dicion√°rios.

√â claro que a maneira apresentada anteriormente n√£o √© din√¢mica o suficiente, pois s√≥ possibilita tr√™s cadastros. Podemos, ent√£o, criar uma inser√ß√£o via teclado dos dados empregando um la√ßo de repeti√ß√£o. Para isso, criamos uma estrutura de lista e uma de dicion√°rio vazias. A l√≥gica aqui √© povoar o dicion√°rio com dados do teclado e, em seguida, colocar o dicion√°rio dentro da lista fazendo um `append`. Vejamos a seguir o c√≥digo.

```python
pessoa = {} # cria um dicion√°rio vazio (para armazenar os dados de cada pessoa)
pessoas = [] # cria uma lista vazia (para armazenar v√°rios dicion√°rios)

for i in range(3): # la√ßo para cadastrar 3 pessoas
  pessoa['nome'] = input('Qual √© o seu nome?')
  pessoa['idade'] = input('Qual √© a sua idade?')
  pessoa['cidade'] = input('Onde voc√™ mora?')
  pessoas.append(pessoa.copy())
print('-' * 20)
for pessoa in pessoas: # percorre a lista de pessoas
  for chave, valor in pessoa.items():
    print(f'O campo {chave} tem o valor {valor}.') 
```

**Nota:** `pessoa.copy()` ****√© fundamental. Se us√°ssemos apenas `pessoas.append(pessoa)`, todas as posi√ß√µes da lista apontariam para o mesmo dicion√°rio, e no final ter√≠amos 3 c√≥pias da √∫ltima pessoa digitada. Com `copy()`, garantimos que cada item da lista seja um dicion√°rio independente.

### 4.2 Dicion√°rios com listas

Um dicion√°rio pode ter listas como valores associados √†s suas chaves. Para preench√™-los, adiciona-se elementos diretamente √†s listas dentro do dicion√°rio.

```python
pessoas = {
    'nome': ['Maria', 'Jo√£o', 'Ana'],
    'idade': [25, 30, 22],
    'cidade': ['Teresina', 'S√£o Paulo', 'Recife']
}
print(pessoas)
# {'nome': ['Maria', 'Jo√£o', 'Ana'], 'idade': [25, 30, 22], 'cidade': ['Teresina', 'S√£o Paulo', 'Recife']}
```

Tamb√©m podemos criar a inser√ß√£o dos dados no dicion√°rio com listas via teclado, assim como v√≠amos anteriormente:

```python
pessoas = {
    'nome': [],
    'idade': [],
    'cidade': []
}

for i in range(3):
    nome = input("Qual √© o seu nome? ")
    idade = input("Qual √© a sua idade? ")
    cidade = input("Onde voc√™ mora? ")

    pessoas['nome'].append(nome)
    pessoas['idade'].append(idade)
    pessoas['cidade'].append(cidade)

print('-' * 20)
print(pessoas)
```

Na linha 1, criamos a estrutura base do dicion√°rio, j√° inserindo as palavras-chave e criando para cada uma delas uma lista completamente vazia. Em seguida, dentro do la√ßo de repeti√ß√£o, fazemos a inser√ß√£o dos dados em vari√°veis simples e, em seguida, fazemos um `append` na respectiva lista do dicion√°rio.

## 5. Trabalhando com m√©todos em strings

- Strings, assim como tuplas, s√£o **imut√°veis**. Tentar alterar um caractere individualmente em uma string resultar√° em um `TypeError`.
    
    ```python
    string = "Python"
    string[0] = "J"  # TypeError: 'str' object does not support item assignment
    ```
    
- **Convers√£o para lista**: Pode-se converter uma string em uma lista de caracteres usando `list(string)`.
    
    ```python
    string = "Python"
    lista = list(string)
    print(lista)
    # ['P', 'y', 't', 'h', 'o', 'n']
    ```
    
    Converter lista de volta em string:
    
    ```python
    texto = ''.join(lista)
    print(texto)
    # Python
    ```
    
- **Verifica√ß√£o de caracteres**:
    - `startswith(prefixo)`: Verifica se a string come√ßa com um prefixo.
    - `endswith(sufixo)`: Verifica se a string termina com um sufixo.
        
        ```python
        string = "L√≥gica de Programa√ß√£o e Algoritmos"
        print(string.startswith("L√≥gica"))    # True
        print(string.endswith("Algoritmos"))  # True
        ```
        
        Esses m√©todos s√£o **case-sensitive:**
        
        ```python
        print(string.startswith("l√≥gica"))    # False
        print(string.endswith("algoritmos"))  # False
        ```
        
- **Alterando mai√∫sculas e min√∫sculas:**
    - `upper()`: Converte todos os caracteres para mai√∫sculas.
    - `lower()`: Converte todos os caracteres para min√∫sculas.
        
        ```python
        print("Python".upper())  # PYTHON
        print("PYTHON".lower())  # python
        ```
        
- **Contagem de caracteres**:
    
    `count(substring)` conta as ocorr√™ncias de um caractere ou substring. Tamb√©m √© case-sensitive, podendo ser combinado com `lower()` para uma contagem inclusiva.
    
    ```python
    string = "banana"
    print(string.count("a"))  # 3
    ```
    
    Tamb√©m √© **case-sensitive:**
    
    ```python
    string = "Banana"
    print(string.count("b"))  # 0
    print(string.lower().count("b"))  # 1
    ```
    
- **Quebra de strings**:
    
    `split(delimitador)` divide uma string em uma lista de substrings, baseando-se em um caractere como divisor. O `split()` recebe como par√¢metro qual caractere ser√° usado para dividir. No exemplo, a string foi quebrada sempre que aparece um espa√ßo.
    
    ```python
    frase = "Python √© divertido"
    palavras = frase.split(" ")
    print(palavras)  # ['Python', '√©', 'divertido']
    ```
    
- **Substitui√ß√£o de strings**:
    
    `replace(antigo, novo, [quantidade])` substitui ocorr√™ncias de uma substring por outra. O terceiro par√¢metro opcional pode limitar o n√∫mero de substitui√ß√µes.
    
    ```python
    string = "Eu gosto de Java"
    novo = string.replace("Java", "Python")
    print(novo)  # Eu gosto de Python
    ```
    
    Com limite de substitui√ß√µes:
    
    ```python
    texto = "abc abc abc"
    novo = texto.replace("abc", "xyz", 2)
    print(novo)  # xyz xyz abc
    ```
    
- **Valida√ß√£o de tipos de dados em strings**: Python oferece v√°rios m√©todos para verificar o conte√∫do de uma string.
    
    ```python
    print("Python3".isalnum())  # True (s√≥ letras e n√∫meros)
    print("Python".isalpha())   # True (s√≥ letras)
    print("123".isdigit())      # True (s√≥ d√≠gitos)
    print("¬Ω".isnumeric())      # True (caractere num√©rico e caracteres matem√°ticos)
    print("HELLO".isupper())    # True (mai√∫sculas)
    print("hello".islower())    # True (min√∫sculas)
    print("   ".isspace())      # True (s√≥ espa√ßos)
    print("Ol√°!".isprintable()) # True (todos imprim√≠veis)
    ```
    

![image.png](/images/divider2.png)

## Exerc√≠cios

**Exerc√≠cio 1:** Crie um programa que contenha uma tupla com o nome de 10 linguagens de programa√ß√£o: Javascript, Rust, Swift, Python, Kotlin, Go, C#, Dart, Julia e Typescript. Em qual posi√ß√£o est√° a linguagem Python? Mostre na tela.

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

i = 0
while linguagens[i] != 'Python':
  i += 1

print(f'Encontramos Python na {i + 1}¬™ posi√ß√£o')
```

**Exerc√≠cio 1.1:** Exibir a posi√ß√£o de todas as linguagens usando um loop.

for:

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

for i in range(len(linguagens)):
  print(f'{i+1}¬™ posi√ß√£o: {linguagens[i]}')

# O la√ßo 'for' itera sobre o √≠ndice de cada elemento
# 'len(linguagens)' retorna o total de elementos (10)
# 'range(len(linguagens))' gera uma sequ√™ncia de 0 a 9
```

while:

```python
linguagens = ('Javascript', 'Rust', 'Swift', 'Python', 'Kotlin', 'Go', 'C#', 'Dart', 'Julia', 'Typescript')

i = 0 # inicializa o contador de posi√ß√£o
while i < len(linguagens):
  print(f'{i+1}¬™ posi√ß√£o: {linguagens[i]}')
  i += 1 # incrementa o contador para a pr√≥xima itera√ß√£o
  
# O la√ßo 'while' continua enquanto o contador for menor que o tamanho da tupla
```

**Exerc√≠cio 2:** Escreva uma fun√ß√£o que contenha dois par√¢metros. Essa fun√ß√£o recebe como par√¢metro uma string com uma mensagem a ser impressa na tela, e outro par√¢metro como sendo uma quantidade arbitr√°ria de n√∫meros empacotados. Dentro da fun√ß√£o, encontre o maior dentre todos os n√∫meros recebidos e escreva na tela, dentro da fun√ß√£o, a mensagem e o maior valor.

```python
# a fun√ß√£o recebe como par√¢metros uma string (msg) e um n√∫mero arbitr√°rio de argumentos empacotados em uma tupla (*num)

def func_maior(msg, *num):
  maior = num[0] # come√ßa assumindo que o primeiro n√∫mero √© o maior
  for i in num: # itera sobre cada n√∫mero na tupla 'num'
    if i > maior:
      maior = i # se o n√∫mero atual 'i' for maior que o valor armazenado em 'maior', 'maior' √© atualizado com o novo valor
  print(msg, maior)

func_maior('maior:', 8, 6, 4, 78, 56, 12, 9) # maior: 78
func_maior('maior:', 10, 2, 55, 34, 1) # maior: 55
```

**Exerc√≠cio 3:** Escreva um algoritmo em Python que crie uma lista vazia e v√° adicionando valores referentes a notas de um aluno nesta lista. Quando o usu√°rio desejar parar de digitar notas (digitando um valor negativo, por exemplo), calcule a m√©dia das notas digitadas.

```python
notas = list() # cria uma lista vazia que vai armazenar as notas

x = float(input('Digite uma nota:')) # pede a primeira nota
while (x >= 0):
  notas.append(x) # enquanto o valor for >= 0, ele adiciona (append) a nota na lista (quando digitado um n√∫mero negativo, o la√ßo √© interrompido)
  x = float(input('Digite uma nota:'))

soma = 0
for valores in notas: # percorre cada valor na lista 'notas'
  soma += valores # soma todas as notas

media = soma/len(notas) # calcula a media
print(notas)
print(f'M√©dia das notas digitadas: {media}') 
```

**Exerc√≠cio 4:** Escreva um algoritmo que leia o nome, a altura e o peso de pessoas, e armazene as informa√ß√µes em uma lista. O programa deve cadastrar um n√∫mero indeterminado de dados e armazenar dentro da lista tamb√©m o IMC da pessoa. Ao final do programa, imprima a lista completa e tamb√©m:

- o total de cadastros;
- a pessoa com o maior IMC;
- a pessoa com o menor IMC.

O c√°lculo do IMC deve ser realizado empregando uma fun√ß√£o lambda e √© dado como: IMC = peso / (altura¬≤).

```python
# cria uma lista vazia para armazenar todos os cadastros de pessoas
pessoas = []

# fun√ß√£o lambda para o c√°lculo do IMC
imc = lambda peso, altura: peso / (altura * altura)

# inicia um la√ßo de repeti√ß√£o infinito para permitir m√∫ltiplos cadastros
while True:
  # solicita os dados
  nome = input('Nome: ')
  altura = float(input('Altura (m): '))
  peso = int(input('Peso (kg): '))
  
  # calcula o IMC usando a fun√ß√£o e armazena o resultado
  x = imc(peso, altura)
  
  # armazena os dados em uma lista
  # em seguida, adiciona esta lista √† lista principal 'pessoas'
  pessoas.append([nome, altura, peso, x])
  
  # pergunta ao usu√°rio se ele deseja continuar ou parar
  res = input('Deseja fazer mais um cadastro? [S/N] ')
  
  # se o usu√°rio digitar 'N' ou 'n', o la√ßo √© interrompido
  if res in 'Nn':
    break

# exibe a lista completa de cadastros no final
print('\nCadastros: ', pessoas)

# exibe o n√∫mero total de cadastros usando a fun√ß√£o len()
print('Total de Cadastros: ', len(pessoas))

# inicializa as vari√°veis para encontrar o maior e menor IMC (com valores fixos funcionam para a maioria dos casos)
maior = 0
menor = 99

# la√ßo para percorrer cada cadastro na lista 'pessoas'
for cadastro in pessoas:
  # verifica se o IMC do cadastro atual √© o maior at√© agora
  if cadastro[3] > maior:
    maior = cadastro[3]
  
  # verifica se o IMC do cadastro atual √© o menor at√© agora
  if cadastro[3] < menor:
    menor = cadastro[3]

# exibe os resultados do maior e menor IMC encontrados
print('\nMaior IMC:',maior)
print('Menor IMC:',menor)

```

**Exerc√≠cio 5:** Dada uma lista contendo as notas de alunos em uma disciplina, escreva uma express√£o para:

notas = [9, 7, 7, 10, 3, 9, 6, 6, 2]

1. Encontrar quantos alunos tiraram nota 7;
2. Alterar a √∫ltima nota para 4;
3. Encontrar a maior nota;
4. Ordenar a lista de notas;
5. M√©dia das notas

```python
print(f'{notas.count(7)} alunos tiraram nota 7.')
notas[-1] = 4
print(notas[-1])
print(max(notas))
notas.sort()
print(notas)
print(sum(notas) / len(notas))
```

**Exerc√≠cio 6:** Escreva um programa que leia um n√∫mero real do usu√°rio e:

1. Calcule a raiz quadrada desse n√∫mero.
2. Calcule o valor arredondado para cima (ceil) e para baixo (floor) desse n√∫mero.
3. Calcule o valor absoluto do n√∫mero.
4. Calcule o seno, cosseno e tangente do n√∫mero (considerando que o n√∫mero est√° em radianos).

```python
import math

num = float(input("Digite um n√∫mero real: "))

# 1. raiz quadrada
raiz = math.sqrt(num)
print(f"Raiz quadrada: {raiz}")

# 2. arredondamento para cima e para baixo
print(f"Arredondamento para cima: {math.ceil(num)}")
print(f"Arredondamento para baixo: {math.floor(num)}")

# 3. valor absoluto
print(f"Valor absoluto: {math.fabs(num)}")

# 4. seno, Cosseno e Tangente
print(f"Seno: {math.sin(num)}")
print(f"Cosseno: {math.cos(num)}")
print(f"Tangente: {math.tan(num)}")
```

>üí° **Biblioteca math**
>    
>    A biblioteca **`math`** em Python √© um m√≥dulo embutido que fornece acesso a fun√ß√µes matem√°ticas comuns, como opera√ß√µes trigonom√©tricas, fun√ß√µes logar√≠tmicas, pot√™ncias e constantes.
>    
>    Para usar qualquer uma dessas fun√ß√µes, voc√™ deve primeiro importar a biblioteca no seu c√≥digo.
>    
>    **Como usar a biblioteca `math`**
>    
>    O primeiro passo √© sempre importar o m√≥dulo. A forma mais comum √© usar a instru√ß√£o `import`.
>    
>    ```python
>    import math
>    ```
>    
>    Ou podemos apenas importar fun√ß√µes espec√≠ficas:
>    
>    ```python
>    from math import sqrt, sin
>    ```
>    
>    Depois de importada, voc√™ pode chamar as fun√ß√µes da biblioteca usando a sintaxe `math.funcao()`.
>    
>    Exemplos de fun√ß√µes √∫teis e como utiliz√°-las:
>    
>    - **`math.sqrt()` -** Calcula a **raiz quadrada** de um n√∫mero.
>        
>        ```python
>        numero = 64
>        raiz_quadrada = math.sqrt(numero)
>        print(f"A raiz quadrada de {numero} √© {raiz_quadrada}")
>        # A raiz quadrada de 64 √© 8.0
>        ```
>        
>    - **`math.pow()` -** Eleva um n√∫mero √† **pot√™ncia** de outro.
>        
>        ```python
>        base = 5
>        expoente = 3
>        potencia = math.pow(base, expoente)
>        print(f"{base} elevado a {expoente} √© {potencia}")
>        # 5 elevado a 3 √© 125.0
>        ```
>        
>        (Note que o operador `**` tamb√©m faz a mesma coisa, como `5 ** 3`).
>        
>    - **`math.floor()` e `math.ceil()` - Arredondamento**`floor()` arredonda um n√∫mero para o inteiro mais pr√≥ximo **abaixo**. `ceil()` arredonda um n√∫mero para o inteiro mais pr√≥ximo **acima**.
>        
>        ```python
>        valor = 4.7
>        abaixo = math.floor(valor)
>        acima = math.ceil(valor)
>        print(f"O n√∫mero {valor} arredondado para baixo √© {abaixo}")
>        print(f"O n√∫mero {valor} arredondado para cima √© {acima}")
>        # O n√∫mero 4.7 arredondado para baixo √© 4
>        # O n√∫mero 4.7 arredondado para cima √© 5
>        ```
>        
>    - **Constantes:** A biblioteca `math` tamb√©m inclui constantes matem√°ticas importantes, como o valor de pi (`pi`) e a base do logaritmo natural (`e`).
>        
>        ```python
>        print(f"O valor de Pi √©: {math.pi}")
>        print(f"O valor de E √©: {math.e}")
>        # O valor de Pi √©: 3.141592653589793
>        # O valor de E √©: 2.718281828459045
>        ```
>        
>    - Algumas fun√ß√µes importantes:
>        
>        
>        | Fun√ß√£o | Descri√ß√£o |
>        | --- | --- |
>        | `math.sqrt(x)` | Raiz quadrada de x |
>        | `math.pow(x, y)` | x elevado √† pot√™ncia y |
>        | `math.ceil(x)` | Arredonda x para cima |
>        | `math.floor(x)` | Arredonda x para baixo |
>        | `math.fabs(x)` | Valor absoluto de x |
>        | `math.sin(x)` | Seno de x (x em radianos) |
>        | `math.cos(x)` | Cosseno de x (x em radianos) |
>        | `math.tan(x)` | Tangente de x (x em radianos) |
>        | `math.log(x)` | Logaritmo natural (base e) |
>        | `math.log10(x)` | Logaritmo na base 10 |
>        | `math.factorial(x)` | Fatorial de x |
>        | `math.pi` | Constante œÄ |
>        | `math.e` | Constante e (base do logaritmo natural) |

**Exerc√≠cio 7:** Escreva um programa em Python que leia o nome de um aluno e tr√™s notas. Armazene em um dicion√°rio o nome e a m√©dia aritm√©tica da nota. Ainda, armazene no dicion√°rio a situa√ß√£o do aluno:

- M√©dia >= 7, aprovado;
- M√©dia < 7 e >= 5, em exame;
- M√©dia < 5, reprovado.

Apresente tudo na tela ao final do programa em um formato organizado.

```python
# criando um dicion√°rio vazio chamado 'aluno'
aluno = {}

# coletando o nome do aluno e armazenando no dicion√°rio
aluno['nome'] = input('Qual o nome do aluno?')

# coletando as tr√™s notas do aluno
n1 = float(input('Qual a primeira nota?'))
n2 = float(input('Qual a segunda nota?'))
n3 = float(input('Qual a terceira nota?'))

# calculando a m√©dia das 3 notas e salvando no dicion√°rio
aluno['media'] = (n1 + n2 + n3) / 3

# verificando a situa√ß√£o do aluno de acordo com a m√©dia
if aluno['media'] >= 7:
  aluno['status'] = 'A' # aprovado
elif aluno['media'] >= 5 and aluno['media'] < 7:
  aluno['status'] = 'E' # em exame
else:
  aluno['status'] = 'R' # reprovado

# exibindo os dados
for chave, valor in aluno.items():
  print(f'{chave} = {valor}')
```