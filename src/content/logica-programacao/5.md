# Funções

Ao longo desta etapa você irá aprender um recurso bastante utilizado e aplicado em qualquer linguagem de programação, o de modularização de códigos. Iremos investigar em linguagem Python como criamos funções. Com elas, poderemos criar rotinas em nossos códigos que irão atender por um nome, deixando nosso código mais legível, simples, e útil.

## 1. Funções

Desde o início dos estudos em Python, o aluno já utiliza funções, embora muitas vezes as chame de "instruções" ou "comandos". Exemplos incluem `input` (manipular teclado), `print` (escrever na tela), `int` e `float` (converter tipos de dados), e `range` (definir intervalo para laços `for`).

- **Definição**: Funções são **rotinas de códigos que podem ser executadas quando seu nome é invocado** dentro do programa. Elas trabalham com o conceito de **abstração**, encapsulando comandos complexos em uma única chamada. Podemos pensar nela como um "mini-programa" que podemos chamar a qualquer momento, sempre que precisar daquela tarefa.
- **Funções pré-definidas**: Existem funções que já vêm com a linguagem, como as mencionadas acima. Cada função contém um algoritmo para resolver uma tarefa menor dentro do programa. Por exemplo, a função `print` tem o objetivo de escrever uma mensagem na tela. O código do `print` (e de outras funções fundamentais) foi escrito em linguagens de baixo nível como C, o que oferece mais controle sobre dispositivos de entrada/saída. O uso de funções predefinidas **facilita o desenvolvimento e torna o código mais portável**.
- **Funções personalizadas**: Nem todos os problemas podem ser resolvidos com funções predefinidas. Por isso, esta aula ensina a **criar rotinas próprias para solucionar problemas particulares**, um processo também conhecido como **modularização de código**.

### 1.1 Primeira função

Observe o código abaixo.

```python
print('|','__' * 10,'|')
print('|','__' * 10,'|')
print('           MENU')
print('|','__' * 10,'|')
print('|','__' * 10,'|')
```

Note que foi necessário escrever 4 vezes a função `print`. Imagine se quiséssemos colocar esse destaque nos textos em diversos momentos ao longo do nosso programa. Seria algo trabalhoso de se fazer. Porém, podemos criar uma função capaz de gerar este realce para nós, somente invocando o seu nome.

Para criar uma função em Python, utiliza-se a palavra-chave **def** (abreviação de *definition*), seguida de um **nome descritivo** para a função, parênteses `()` (que são obrigatórios) e finaliza-se com dois pontos `:`. O código indentado abaixo da definição constitui o **corpo da função**.

**Exemplo**: A função `realce()` é criada para imprimir linhas de destaque.

```python
def realce():
  print('|','__' * 10,'|')
  print('|','__' * 10,'|')
```

Com a função `realce()` definida, sempre que invocar o seu nome em qualquer programa Python, estaremos automaticamente executando o código dentro desta função. Vejamos o nosso primeiro exemplo agora com a função criada. Note que a saída do programa é idêntica, exatamente como deveria ser.

```python
realce()
print('          MENU')
realce()
```

- A **definição da função não a executa**; ela apenas a torna disponível no programa. Para executá-la, é necessário **invocar seu nome** no programa principal.

### 1.2 Fluxo de execução de um programa contendo funções

Um programa é executado linha por linha, de cima para baixo. Quando uma função é invocada, a **execução do algoritmo principal (no qual a função foi chamada) é interrompida**, o corpo da função é executado por completo, e **após a conclusão da função, o programa principal é retomado** a partir da linha seguinte à chamada da função.

- **Importante**: Qualquer função deve ser **definida antes de ser invocada pela primeira vez**, caso contrário, o algoritmo resultará em um erro de compilação por não reconhecer a função, pois não saberá que ela existe.

## 2. Parâmetros em Funções

Funções podem **receber dados (variáveis) do programa principal** (ou de outras funções) e manipulá-los. Esses dados recebidos são chamados de **parâmetros**, e o ato de enviá-los é a **passagem de parâmetro**. Uma função pode ter **quantos parâmetros desejar**, e nem todos são obrigatórios (como visto em `range`).

**Sintaxe de parâmetros**: Para criar uma função com parâmetros, os nomes das variáveis que receberão os dados são inseridos dentro dos parênteses na definição da função. Múltiplos parâmetros são separados por vírgulas.

**Exemplo**: A função `realce(frase)` é adaptada para receber a string a ser destacada como parâmetro, imprimindo-a entre as linhas de destaque.

Agora, dentro dos parênteses inserimos o nome de uma variável: `frase`. Esta variável servirá para receber como parâmetro a string colocada durante a chamada da função. Assim, nosso programa principal ficará com somente uma linha de código.

```python
def realce(frase):
    print('|','__' * 10,'|')
    print('|','__' * 10,'|')
    print(frase)
    print('|','__' * 10,'|')
    print('|','__' * 10,'|')
    
realce('          MENU')
```

Quando o `realce(frase)` é invocado, ela faz todos os `print` e também recebe a nossa palavra como parâmetro e a usa para também imprimir na tela.

Vamos criar uma função que recebe **dois parâmetros**. A função que iremos criar realiza a subtração de dois valores quaisquer. Sendo assim, iremos chamá-la de `sub` e ela terá duas variáveis (`x` e `y`) recebidas como parâmetro. Veja a seguir como fica a função e também a chamada dela no programa principal:

```python
def sub(x, y):
  res = x - y
  print(res)

sub(10, 7) # 3
```

- **Ordem dos parâmetros**: A **ordem em que os parâmetros são passados é crucial**, pois determina qual valor é atribuído a qual variável dentro da função. Note que, como temos mais de um parâmetro, a ordem por meio da qual nós os passamos dentro dos parênteses faz toda a diferença. Se olharmos para a definição da função, o primeiro parâmetro é a variável `x`, e o segundo a variável `y`. Isso significa que quando escrevemos `sub(10, 7)`¸ estamos fazendo com que x = 10 e y = 7¸ e portanto, x - y = 10 - 7 = 3. Se invertermos a ordem dos parâmetros, o resultado da subtração será diferente, pois teremos x = 7 e y = 10 (7 – 10 = -3).
- Embora Python permita passar parâmetros fora de ordem especificando o nome da variável (ex: `sub(y=10, x=7)`), é **recomendável manter a ordem** para melhor legibilidade.

### 2.1 Parâmetros opcionais

Parâmetros opcionais aumentam a **flexibilidade das funções**, permitindo que alguns parâmetros sejam omitidos na chamada da função. Isso é comum em funções como `range`.

Vamos criar uma função que soma até 3 valores. Se criarmos a função da maneira convencional como aprendemos até então, teremos o código a seguir, em que recebemos 3 valores (x, y e z), calculamos a soma e fazemos o print do resultado na tela. Mas essa função nos limita a passar exatamente 3 valores. Passar 2 valores, por exemplo, gera um erro.

```python
def soma(x, y, z):
  res = x + y + z
  print(res)

soma(3, 3) # TypeError: soma() missing 1 required positional argument: 'z'
```

Para solucionar isso, podemos deixar com que os parâmetros sejam opcionais. Isso significa que, caso quisermos somar somente dois valores, seria possível, omitindo o terceiro parâmetro. Para isso, basta colocarmos um valor padrão no momento da criação das variáveis da função. Assim, caso um dos parâmetros seja omitido, o valor padrão é usado.

**Exemplo**: A função abaixo pode ser chamada com um, dois ou nenhum argumento, usando 0 como padrão para os parâmetros omitidos.

```python
def soma(x = 0, y = 0, z = 0):
  res = x + y + z
  print(res)

soma(1,2,3) # 6
soma(1,2)   # 3 (z=0 por padrão)
soma()      # 0 (x, y, z=0 por padrão)
```

## 3. Escopo de Variáveis

O **escopo** de uma variável define onde ela pode ser utilizada dentro de um programa. Existem dois tipos principais de escopos:

- **Escopo local**: Variáveis criadas **dentro do corpo de uma função** (incluindo parâmetros) são **variáveis locais**. Elas só existem dentro daquela função e são **destruídas** quando a função se encerra, limpando-as da memória. Cada vez que a função é chamada, um novo escopo local é criado, reiniciando os valores das variáveis.
- **Escopo global**: Variáveis criadas no **programa principal** são **variáveis globais**. Uma variável global existe e é acessível em todas as funções invocadas ao longo do programa.

**Vantagem dos escopos locais**: Minimiza bugs e acelera a detecção de erros, pois os problemas ficam confinados ao escopo local de uma função.

**Regras de acesso**:

- Um código no escopo global **não pode usar nenhuma variável local** de uma função.
- Um código no escopo local (dentro de uma função) **pode acessar uma variável global**.
- **Nenhum escopo local pode acessar as variáveis de outro escopo local**.
- É possível ter **diversas variáveis com o mesmo nome**, desde que estejam em escopos distintos (global e locais diferentes), mas não é recomendado.
- Se uma variável existe tanto no escopo global quanto no local com o mesmo nome, no escopo local, a **variável local terá prioridade** e será a manipulada.
- Uma variável tem seu escopo definido no momento da criação e **não pode ser alterada** durante a execução.
- Tentar imprimir uma variável local sem tê-la definido localmente resultará em um erro (`UnboundLocalError`), mesmo que exista globalmente, pois Python tentará criar uma nova variável local sem valor atribuído.

### 3.1 Instrução global

A instrução `global` é usada dentro de uma função para **forçar o programa a manipular uma variável global existente** em vez de criar uma nova variável local com o mesmo nome.

- **Exemplo**: Ao usar `global x` dentro de uma função, qualquer alteração em `x` dentro dessa função afetará a variável global `x`.

## 4. Retorno de Valores em Funções

Até o momento você aprendeu a criar rotinas que são executadas, mas que nunca geram um resultado a ser devolvido ao programa principal, ou mesmo a outra função que a chamou. De acordo com Puga e Risseti (2016, p. 102), as rotinas de código que nunca retornam um dado são chamadas de procedimento (procedure). Diferente de um procedimento, uma função é dada como sendo uma rotina que retorna valores associados ao seu nome. Desse modo, uma função pode ser empregada em atribuições ou mesmo em expressões lógicas.

Embora haja essa distinção conceitual, é comum usar "função" para ambos os casos.

- **return**: Para retornar um valor de uma função, utiliza-se a palavra-chave `return` seguida do valor ou da variável cujo conteúdo se deseja retornar.
- **Recebendo o valor de retorno**: No programa principal (ou na função chamadora), o valor retornado pela função deve ser **armazenado em uma variável**.

**Exemplo**: Vejamos como criar e manipular uma função com retorno. Vamos voltar a uma função criada anteriormente, que soma até 3 valores numéricos:

```python
def soma(x = 0, y = 0, z = 0):
  res = x + y + z
  print(res)
```

Agora, suponha que não queremos mais realizar o print dentro dessa função. Vamos querer na verdade somente receber o resultado do somatório final para então fazermos um print no próprio programa principal. Para isso, iremos utilizar o recurso de retorno de valores em funções. Utilizaremos a palavra-chave `return` para resolver nosso problema. Veja como ficaria nossa nova função com retorno:

```python
# A função 'soma' recebe 3 parâmetros, soma-os e retorna o resultado.
def soma(x=0, y=0, z=0):
	res = x + y + z
	return res

# O valor retornado pela função pode ser armazenado em uma variável.
soma_total = soma(1, 2, 3)
print(f"O resultado do somatório é: {soma_total}") # O resultado do somatório é: 6

# O valor retornado também pode ser usado diretamente, sem ser armazenado.
print(soma(2, 2)) # 4
```

Uma das grandes vantagens de usar a instrução `return` em funções é a possibilidade de retornar diferentes valores dependendo de uma condição específica. Isso elimina a necessidade de fazer o `print` dentro da função, permitindo que o programa principal decida o que fazer com o resultado.

No exemplo do "par ou ímpar", em vez de imprimir a mensagem, a função `par_impar(x)` retorna a string `"par"` ou `"ímpar"`:

```python
def par_impar(x):
  if (x % 2 == 0):
    return 'par'
  else:
    return 'ímpar'
    
print(par_impar(int(input('Digite um valor inteiro: '))))
```

Ao executar o código, apenas um dos `return` é ativado, dependendo se a condição for verdadeira ou falsa. O valor retornado é então usado no programa principal, onde pode ser impresso, armazenado em uma variável ou utilizado em outras operações.

## 5. Recursos Avançados com Funções

### 5.1 Exceções e Erros

Existem dois tipos principais de erros em programação:

1. **Erros de Sintaxe (SyntaxError)**: Ocorrem quando há um erro de digitação, esquecimento de palavra-chave/caractere, ou erro de indentação. Geralmente, o interpretador indica a linha do erro.

```python
print("Olá mundo"   # SyntaxError: incomplete input
```

2. **Exceções**: Ocorrem durante a **execução do programa**, mesmo que a sintaxe esteja correta. São geralmente causadas por dados inválidos ou cenários não previstos pelo programador. Exemplos comuns incluem:

- `ZeroDivisionError`: Divisão por zero.
    
    ```python
    print(100 * (2/0)) # ZeroDivisionError: division by zero
    ```
    
- `ValueError`: Entrada de dados de tipo incorreto (ex: usuário digita 'c' onde se espera um `int`).
    
    ```python
    n = int(input("Digite um número: ")) # Digitar letras gera ValueError
    print(f"O número digitado foi {n}") # ValueError: invalid literal for int() with base 10: 'abc'
    ```
    

**Tratamento de exceções com `try-except`**:

- A estrutura **try** tenta executar um bloco de código.
    
    ```python
    while True:
      try: # O código que pode causar um erro fica dentro do 'try'
        n = int(input("Digite um número inteiro: "))
        print(f"Você digitou: {n}")
        break
      except ValueError: # Se uma exceção ValueError ocorrer, este bloco será executado
        print("Erro: você não digitou um número válido!")
    ```
    
    - Se uma exceção ocorre no bloco `try`, a execução é transferida para o bloco **except**, que especifica o tipo de exceção a ser tratada. Isso impede que o programa pare e permite que uma mensagem de erro ou lógica alternativa seja executada.
- Podem haver **múltiplos blocos** `except` para tratar diferentes tipos de exceções (ex: `ValueError` e `IndexError`) ou um `except` genérico para qualquer exceção não especificada.
    
    ```python
    i = 1
    nome = input('Por favor digite o seu nome: ')
    
    while True:
      try:
        ind = (int(input('Digite um índice do seu nome digitado: '))-1)
        print(nome[ind])
        print("Sucesso! A entrada é válida.")
        break
      except ValueError:
        print('Oops! O índice precisa ser um número inteiro. Tente novamente...')
      except IndexError:
        print('Oops! O índice digitado não existe no seu nome. Tente novamente...')
      finally:
        print(f'Tentativa {i}')
        i += 1
    ```
    
    ```python
    i = 1
    nome = input('Por favor digite o seu nome: ')
    
    while True:
      try:
        ind = (int(input('Digite um índice do seu nome digitado: '))-1)
        print(nome[ind])
        print("Sucesso! A entrada é válida.")
        break
      except: # se o usuário digitar qualquer dado inválido (índice fora do alcance ou não numérico), exibe uma mensagem de erro genérica.
        print('Oops! Algo deu errado. Tente novamente...')
      finally:
        print(f'Tentativa {i}')
        i += 1
    ```
    
- O bloco **finally** (opcional) é executado **sempre**, independentemente de uma exceção ter ocorrido ou não. É útil para código de limpeza ou que deve ser executado em qualquer situação.
- O bloco **else** (opcional) é executado **apenas se nenhuma exceção ocorrer** no bloco `try`.

O tratamento de exceções é comumente isolado em funções para manter a lógica principal do programa limpa e focada.

### 5.2 Função Lambda

Python permite a criação de **funções anônimas e mais simples, sem nome**, chamadas **funções lambda**. Elas são escritas em uma única linha de código e são úteis quando você precisa de uma função simples por um curto período de tempo, geralmente para ser usada como argumento em outras funções que esperam uma função, como `map()`, `filter()` ou `sorted()`.

- **Sintaxe**
    
    ```python
    lambda argumentos: expressão
    ```
    
    - **`lambda`**: palavra-chave que indica a criação de uma função lambda.
    - **`argumentos`**: parâmetros de entrada da função (pode ter um, vários ou nenhum).
    - **`expressao`**: operação que a função vai executar e cujo resultado será retornado.
- **Função normal**
    
    ```python
    def somar(x, y):
      return x + y
    print(somar(5, 3)) # 8
    ```
    
- **Função Lambda**
    
    ```python
    somar = lambda x, y: x + y
    print(somar(5, 3)) # 8
    ```
    

![image.png](/images/divider2.png)

## Exercícios

**Exercício 1:** Crie uma função para calcular a idade de uma pessoa com base no ano de nascimento (cosiderar apenas o ano para o cálculo).

```python
def idade(ano_nascimento):
	ano_atual = 2025
	idade = ano_atual - ano_nascimento
	return idade

minha_idade = idade(1998)
print(f"Eu tenho {minha_idade} anos.")

idade_2 = idade(2000)
print(f"A idade é {idade_2} anos.")
```

**Exercício 2:** Escreva uma função que crie um laço de repetição que faz uma contagem e imprime esta contagem na tela. Porém, como parâmetro, a função deve receber o valor inicial da contagem, o final, e o passo da iteração. Deixe os parâmetros inicial e de passo como opcionais. Você pode fazer o laço com for ou com while.

```python
def contador(fim, inicio = 0, passo = 1):
  for i in range(inicio, fim+1, passo):
    print(f'{i}')
  print('\n')
  
contador(20, 10, 2)
contador(12)
```

**Exercício 3:** Escreva uma função para validar uma string. Essa função recebe como parâmetro a string, o número mínimo e máximo de caracteres. Retorne verdadeiro se o tamanho da string estiver entre os valores de mínimo e máximo, e falso, caso contrário.

```python
def valida_string(pergunta, min, max):
  string = input(pergunta)
  tam = len(string)
  while ((tam < min) or (tam > max)):
    string = input(pergunta)
    tam = len(string)
  return string

x = valida_string('Digite uma string de 8 a 20 caracteres: ', 8, 20)
print(f'Você digitou a string: {x}. Dado válido. Encerrando o programa...')
```

**Exercício 4: Manipulando arquivos**

Suponha que você é um colecionador de jogos de videogame. Escreva um algoritmo que permita cadastrar esses jogos informando o nome e a qual videogame ele pertence. Para isso, crie um menu de opções contendo: cadastrar novo item, listar tudo que foi cadastrado e sair. Para resolver esse exercício, crie pelo menos uma função para cada item do menu. Além disso, armazene todos os dados em um arquivo  de texto que deve ser salvo em disco e manter os dados cadastrados.

```python
def valida_int(pergunta, min, max):
  x = (int(input(pergunta)))
  while ((x < min) or (x > max)):
    x = int(input(pergunta))
  return x

def existeArquivo(nomeArquivo):
  try:
    a = open(nomeArquivo, 'rt')
    a.close()
  except FileNotFoundError:
    return False
  else:
    return True

def criarArquivo(nomeArquivo):
  try:
    a = open(nomeArquivo, 'wt+')
    a.close()
  except:
    print('Erro na criação do arquivo')
  else:
    print(f'Arquivo {nomeArquivo} foi criado com sucesso!\n')

def cadastrarJogo(nomeArquivo, nomeJogo, nomeVideogame):
  try:
    a = open(nomeArquivo, 'at')
  except:
    print('Erro ao abrir o arquivo')
  else:
    a.write(f'O nome do jogo é: {nomeJogo};O videogame é: {nomeVideogame}\n')
    print('Jogo cadastrado com sucesso!\n')
  finally:
    a.close()

def listarArquivo(nomeArquivo):
  try:
    a = open(nomeArquivo, 'rt')
  except:
    print('Erro ao ler o arquivo')
  else:
    print(a.read())
  finally:
    a.close()

arquivo = 'games.txt'
if existeArquivo(arquivo):
  print('Arquivo localizado no computador')
else:
  print('Arquivo inexistente')
  criarArquivo(arquivo)

while True:
  print('MENU')
  print('1 - Cadastrar novo item')
  print('2 - Listar itens')
  print('3 - Sair')

  opcao = valida_int('Escolha uma opção: ', 1, 3)
  if (opcao == 1):
    print('Cadastrando novo item/n')
    nomeJogo = input('Nome do jogo: ')
    nomeVideogame = input('Nome do videogame: ')
    cadastrarJogo(arquivo, nomeJogo, nomeVideogame)
  elif (opcao == 2):
    print('Listar itens/n')
    listarArquivo(arquivo)
  elif (opcao == 3):
    print('Programa encerrado')
    break
```